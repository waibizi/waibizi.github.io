<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>歪鼻子</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://waibizi.github.io/"/>
  <updated>2020-06-10T18:36:11.179Z</updated>
  <id>https://waibizi.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Java设计模式】代理模式</title>
    <link href="https://waibizi.github.io/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://waibizi.github.io/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-10T18:21:31.000Z</published>
    <updated>2020-06-10T18:36:11.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java代理模式的基本介绍"><a href="#1-Java代理模式的基本介绍" class="headerlink" title="1.Java代理模式的基本介绍"></a>1.Java代理模式的基本介绍</h2><p>  首先得跟大家说明白，本篇文章的设计模式实现是基于<font color="#00FA9A">Java语言</font>的，思想还是代理的思想，不要纠结于我为什么将静态代理，动态代理，cglib代理分开来说（只能说技术是技术，思想是思想）</p><p><font color=" #FF8C00">代理模式：</font>为一个对象提供一个替身，以控制对这个对象的访问;即通过代理对象访问目标对象;这样做的好处是可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能;</p><p>被代理的对象可以是<font color=" #FF8C00">远程的对象</font>、开销大的对象或者需要被安全控制保护的对象;</p><p>Java的手段实现代理模式的手段主要有三种：<font color="#00FA9A">静态代理，动态代理（JDK代理、接口代理）和cglib代理（cglib代理主要是可以在内存中创建对象，不用实现接口）</font></p><center>代理模式的类图如下</center><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/1.png" class title="This is an image"><p>  我们要调用<font color="#00FA9A">TargetObject类</font>，也就是目标类的时候，我们（Client）采用调用代理(ProxyObject)的方式去调用最终目标类，进而达到隐藏真正目标类</p><h2 id="2-Java实现静态代理"><a href="#2-Java实现静态代理" class="headerlink" title="2.Java实现静态代理"></a>2.Java实现静态代理</h2><p>静态代理：静态代理在使用的时候，需要定义接口或者是父类，被代理对象（即目标对象TargetObject）与代理对象（ProxyObject）一起实现相同的接口或者是继承相同的父类</p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/2.png" class title="This is an image"><p>类图的意思：假如我是客户（Client）我要去租房，我找到了租房中介（RentingProxy），租房中介与房东（Renting）之间签订了一定的约束，也就是条约。这是采用IRenting来约束;然后我需要租房的时候，只需要找到租房中间去租房就行了，我知道我要租哪间房，我直接调用租房中介有的方法，而租房中介可以帮我处理一些增强方法，例如会提前帮我去看房子合不合格之类的（称之为增强方法）;</p><p>代码如下：</p><center>包结构</center><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/3.png" class title="This is an image"><p>客户端类，创建了目标对象，创建了代理对象，然后将目标对象交付给代理对象，使用代理对象执行方法;</p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/4.png" class title="This is an image"><center>目标对象与代理对象应该遵守的合约</center><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/5.png" class title="This is an image"><center><font color="#00FA9A">目标对象</font></center><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/6.png" class title="This is an image"><p>代理对象，我们可以做一些增强操作</p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/7.png" class title="This is an image"><p>Client启动，执行main方法打印</p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/8.png" class title="This is an image"><h2 id="3-JDK代理"><a href="#3-JDK代理" class="headerlink" title="3.JDK代理"></a>3.JDK代理</h2><p>这里顺便介绍一下动态代理</p><p>1.代理对象，不需要实现接口，但是目标对象需要实现接口，</p><p> 否则不能使用动态代理</p><p>2.代理对象的生成，是利用了JDK的API，动态地在内存中构建</p><p> 对象</p><p>3.动态代理也叫：<font color=" #FF8C00">JDK代理、接口代理</font></p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/9.png" class title="This is an image"><p>采用的案例还是上面那个租房子的案例</p><center><font color=" #FF8C00">包结构</font></center><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/10.png" class title="This is an image"><center><font color=" #FF8C00">Client类</font></center><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/11.png" class title="This is an image"><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/12.png" class title="This is an image"><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/13.png" class title="This is an image"><p>这里的JDK动态代理可能会比较难懂，参数的意义我已经加上了</p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/14.png" class title="This is an image"><h2 id="4-Cglib代理"><a href="#4-Cglib代理" class="headerlink" title="4.Cglib代理"></a>4.Cglib代理</h2><p>1.静态代理和JDK动态代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可使用目标对象子类来实现代理，这就是Cglib代理;</p><p>2.Cglib代理也叫子类代理，他是在内存中构建一个子类对象从而实现对象功能扩展;</p><p>3.Cglib是一个强大的高性能代码生成包，可以在运行期间扩展Java类与实现Java接口;广泛地被许多AOP框架所使用，例如Spring AOP，实现方法拦截;</p><p>4.AOP编程当中应该如何选择代理模式</p><p>  1）.目标对象需要实现接口，用JDK代理</p><p>  2）.目标对象不需要实现接口，用Cgglib代理</p><p>5.Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类</p><center><font color=" #FF8C00">【注意】</font></center><p>需要代理的类也就是目标类不能使用final修饰</p><p>如果目标类的方法是static/final修饰的，也不能</p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/15.png" class title="This is an image"><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/16.png" class title="This is an image"><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/17.png" class title="This is an image"><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/18.png" class title="This is an image"><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/19.png" class title="This is an image">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Java代理模式的基本介绍&quot;&gt;&lt;a href=&quot;#1-Java代理模式的基本介绍&quot; class=&quot;headerlink&quot; title=&quot;1.Java代理模式的基本介绍&quot;&gt;&lt;/a&gt;1.Java代理模式的基本介绍&lt;/h2&gt;&lt;p&gt;  首先得跟大家说明白，本篇文章的设
      
    
    </summary>
    
    
      <category term="-设计模式" scheme="https://waibizi.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="-Java -设计模式" scheme="https://waibizi.github.io/tags/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>再谈自动装箱(AutoBoxing)，自动拆箱(Unboxing)</title>
    <link href="https://waibizi.github.io/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/"/>
    <id>https://waibizi.github.io/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/</id>
    <published>2020-06-09T14:49:29.000Z</published>
    <updated>2020-06-09T15:03:19.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h2><p>  自动装箱就是自动将基本数据类型转换为<strong>包装器类型</strong>；自动拆箱就是自动将包装器类型转换为<strong>基本数据类型</strong>。</p><p>  ps：Integer自动转换为<strong><font color=" #FF8C00">int</font></strong>类型，这个就是自动拆箱的过程，int自动转换为Integer就是装箱的过程。</p><img src="/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/1.png" class title="This is an image"><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h2><p>  概念不难理解，不如尝试反编译一下，看下底层是什么什么吧。</p><p>  废话少说，直接动手肝</p><p>点击查看大图</p><img src="/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/2.png" class title="This is an image"><p>  通过<strong><font color=" #FF8C00">反编译字节码</font></strong>可以很明显地看到一些效果，将<strong><font color=" #FF8C00">装箱与拆箱</font></strong>的过程反映了出来。</p><h2 id="3-自动装箱与拆箱的一些验证"><a href="#3-自动装箱与拆箱的一些验证" class="headerlink" title="3.自动装箱与拆箱的一些验证"></a>3.自动装箱与拆箱的一些验证</h2><img src="/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/3.png" class title="This is an image"><p>打印结果是<strong><font color=" #FF8C00">true</font></strong>，此步进行了自动拆箱操作</p><p><font color="#00FA9A">拆箱</font>的验证，可以通过<font color="#00FA9A">字节码</font>看到</p><img src="/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/4.png" class title="This is an image"><center>再来一次，这次使用<font color="#00FA9A">equals</font>,可以看到是装箱了</center><img src="/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/5.png" class title="This is an image"><p>具体原因是因为jdk内部使用equals的时候，传入是Object，int类型赋值到Object的时候是装箱的过程</p><img src="/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/6.png" class title="This is an image"><p><strong>小结</strong></p><p>1.自动装箱与自动装箱虽然在使用当中可以省略很多不用考虑的因素，但是这是因为Java自己做了这部分的工作（只是你看不到）;</p><p>2.大量使用自动装箱会影响一部分的性能（因为要生成Object类型）;</p><p>3.采用‘==’与‘equals’的时候，自动装箱与自动拆箱的原因为啥不同;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-基础概念&quot;&gt;&lt;a href=&quot;#1-基础概念&quot; class=&quot;headerlink&quot; title=&quot;1.基础概念&quot;&gt;&lt;/a&gt;1.基础概念&lt;/h2&gt;&lt;p&gt;  自动装箱就是自动将基本数据类型转换为&lt;strong&gt;包装器类型&lt;/strong&gt;；自动拆箱就是自动将包装
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【CAS基础】CAS简单入门</title>
    <link href="https://waibizi.github.io/2020/06/09/%E3%80%90CAS%E5%9F%BA%E7%A1%80%E3%80%91CAS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"/>
    <id>https://waibizi.github.io/2020/06/09/%E3%80%90CAS%E5%9F%BA%E7%A1%80%E3%80%91CAS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</id>
    <published>2020-06-09T13:42:43.000Z</published>
    <updated>2020-06-09T14:47:29.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-CAS概念"><a href="#1-CAS概念" class="headerlink" title="1.CAS概念"></a>1.CAS概念</h2><p>  首先，跟大家强调一下，CAS是一种思想！！一种思想！！一种思想！！！（重要的话说三次）</p><p>  CAS的的英文全称<strong><font color=" #FF8C00">Compare-and-Swap</font></strong>，中文名称叫做比较并交换，一种才不采用强制性锁机制下的一种值更新策略；在并发的情况下，挺多情况是直接synchronized跟voliate或者其他锁机制实现并发时保证数据一致性的;</p><h2 id="2-CAS的一个小Demo"><a href="#2-CAS的一个小Demo" class="headerlink" title="2.CAS的一个小Demo"></a>2.CAS的一个小Demo</h2><p>  CAS呢，底层是在unsafe类当中的，但是JDK当中有许多类都会采用CAS去保障数据的并发问题，我们简单看一个并发包当中的类，然后去认识CAS吧;</p><img src="/2020/06/09/%E3%80%90CAS%E5%9F%BA%E7%A1%80%E3%80%91CAS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/1.png" class title="This is an image"><center>这是一个安全的int，我初始化这个int为5，然后采用了</center><center>AtomicInteger的CAS实现</center><center>大概就是expect期望值是5的话，把值改为update的值</center><center>然后我们就简单进去源码看下吧····</center><img src="/2020/06/09/%E3%80%90CAS%E5%9F%BA%E7%A1%80%E3%80%91CAS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/2.png" class title="This is an image"><p>参数的意思:</p><p><font color=" #FF8C00">this</font>：当前对象</p><p><font color=" #FF8C00">valueOffset</font>：内存地址</p><p><font color=" #FF8C00">expect</font>：期待值</p><p><font color=" #FF8C00">update</font>：更新值</p><p>再往下看就不是我们此时关注的重点啦，因为再往下就是unsafe类</p><p>这个类我会的后续再写一篇介绍</p><p>（真的是太多了）</p><h2 id="3-CAS的缺点以及ABA问题"><a href="#3-CAS的缺点以及ABA问题" class="headerlink" title="3.CAS的缺点以及ABA问题"></a>3.CAS的缺点以及ABA问题</h2><p>  <font color="#7B68EE" size="5">无锁机制固然好，但是有一些比较明显的缺点也随着带来了，我们先来简单说一下CAS当中自旋出现的问题;</font></p><p>假设我现在有两个线程：线程A与线程B，然后有一个变量，表示的是卡上的余额;</p><p>线程A，此时知道的初始值是50元，线程B也是晓得此时初始值是50元：</p><p>线程A想把50更新为100，线程B想把50更新为零，那么此时线程A与线程B的“期望值”都是50，线程A的运气比较好，先抢占到时间片，开始更新数据，并且更新数据成功。而线程B因为一些中间处理操作，需要时间等待，此时拿着期望值“50”，进行CAS比较交换的时候，发现期望值无效，于是重新获取了一次最新的“真实值”，然后很不凑巧，线程A此时又想修改值，而且时间片也被线程A抢占了，线程A此时拿着最新的期望值是“100”，又更新成功了，把值重新改回50，而线程B这倒霉蛋又拿着期望值为“100”的，想过来修改值，又没办法修改···</p><p>如果线程B一直运气不好，抢不到时间片，就会导致线程B一直处于自旋的状态···</p><p>【ABA问题】</p><p>ABA问题比较好理解</p><p>  1.线程A，期望值是50，欲更新值为100</p><p>  2.线程B，期望值是50，欲更新值为100</p><p>  线程A首先拿到时间片，进行值的更新，此时线程B因为某些问题（阻塞了一段时间），没有抢占到时间片。此时A更新了值了，然后突然来了一个线程C，比线程B先抢占到了时间片（线程B挺可怜的），此时线程C的期望值是100，欲修改值是50，CAS执行成功了，此时线程B终于阻塞完了，拿着期望值为50，更新值为100的操作姗姗来迟，此时CAS也成功了。可是线程B并不知道他自己修改了的值是经过了50-&gt;100-&gt;50-&gt;100。除开掉前面的50是初始值，100,50,100三个数就是ABA的代表，可以将100替换为A理解，50替换为B理解。</p><p>这个ABA会导致什么问题的出现呢？</p><p>如果说此时我的银行卡收入了50元，卡内原先余额为50元，此时就要更新为100元，由于一些比较特殊的原因（难不成是工程师的锅），此时50欲更新为100有两条线程，就跟上面例子一样;然后此时突然我的女朋友想要花我的银行卡的钱，我的银行卡也需要扣费了，三个线程出现了上面那种执行顺序问题，我的卡此时不就白白赚了50块钱了吗？（可能例子不大恰当，但是ABA当中就是这种问题的发生）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-CAS概念&quot;&gt;&lt;a href=&quot;#1-CAS概念&quot; class=&quot;headerlink&quot; title=&quot;1.CAS概念&quot;&gt;&lt;/a&gt;1.CAS概念&lt;/h2&gt;&lt;p&gt;  首先，跟大家强调一下，CAS是一种思想！！一种思想！！一种思想！！！（重要的话说三次）&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="-Java基础" scheme="https://waibizi.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="CAS" scheme="https://waibizi.github.io/tags/CAS/"/>
    
      <category term="Java" scheme="https://waibizi.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
