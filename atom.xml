<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>歪鼻子</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://waibizi.github.io/"/>
  <updated>2020-09-04T05:40:21.144Z</updated>
  <id>https://waibizi.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什么是微服务？0202年了，你还不知道微服务？</title>
    <link href="https://waibizi.github.io/2020/09/04/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%9F0202%E5%B9%B4%E4%BA%86%EF%BC%8C%E4%BD%A0%E8%BF%98%E4%B8%8D%E7%9F%A5%E9%81%93%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%9F/"/>
    <id>https://waibizi.github.io/2020/09/04/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%9F0202%E5%B9%B4%E4%BA%86%EF%BC%8C%E4%BD%A0%E8%BF%98%E4%B8%8D%E7%9F%A5%E9%81%93%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%9F/</id>
    <published>2020-09-04T05:40:05.000Z</published>
    <updated>2020-09-04T05:40:21.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是微服务？0202年了，你还不知道微服务？"><a href="#什么是微服务？0202年了，你还不知道微服务？" class="headerlink" title="什么是微服务？0202年了，你还不知道微服务？"></a>什么是微服务？0202年了，你还不知道微服务？</h1><h2 id="1-微服务概念"><a href="#1-微服务概念" class="headerlink" title="1.微服务概念"></a>1.微服务概念</h2><p>想知道什么是微服务，首先我们得先认识什么是单体架构，如果你的日常开发当中没有接触微服务，那么你接触的架构风</p><p>格都是单体架构，那么，究竟是什么单体呢？在以往的开发当中我们都是把一个系统全部“塞”到一个Web容器当中，也就</p><p>是一个系统所有的业务都是存放到一起的，我们把这种架构风格称之为单体架构。</p><p>微服务就是将我们平时单体架构的业务，以服务为粒度将原先单体的业务进行拆分，服务之间互相协调、互相配合，为用</p><p>户提供最终价值。每个服务运行在其独立的进程中，服务与服务采用轻量级的通信机制互相沟通（一般都是基于HTTP协</p><p>议的RESTful API）。每个服务都围绕具体业务进行构建，并且能够被独立部署到生成环境，类生成环境等。</p><h2 id="2-为什么要用微服务"><a href="#2-为什么要用微服务" class="headerlink" title="2.为什么要用微服务"></a>2.为什么要用微服务</h2><p>这个疑问可能是大部分都会思考的，原先单体不是好好的吗？为什么要使用微服务？就像前面所说的，如果采用微服务的</p><p>话，我们还得考虑服务之间的调用问题等等····</p><p>那我们就来比较单体架构与微服务架构的特点吧</p><div align="center"><img src="https://www.waibizi.com/group1/M00/00/05/rBpUXl9N10qAAgKxAAJO-Yqh5Wg531.jpg" height="90%" width="90%"></div><h2 id="3-怎么设计微服务"><a href="#3-怎么设计微服务" class="headerlink" title="3.怎么设计微服务"></a>3.怎么设计微服务</h2><p>任何一种架构都有自己的设计风格，微服务也不例外，微服务的架构风格主要有以下四点</p><div align="center"><img src="https://www.waibizi.com/group1/M00/00/05/rBpUXl9N2sGALDJpAAIlBVZilJo547.jpg" height="50%" width="50%"></div><h3 id="一、AKF扩展划分"><a href="#一、AKF扩展划分" class="headerlink" title="一、AKF扩展划分"></a>一、AKF扩展划分</h3><div align="center"><img src="https://www.waibizi.com/group1/M00/00/05/rBpUXl9N3A2AJeYHAACiK0KcUbg925.jpg" height="50%" width="50%"></div><p>AKF扩展立方体(参考《The Art of Scalability》)，是一个叫AKF的公司的技术专家抽象总结的应用扩展的三个维度。理论上按照这三个扩展模式，可以将一个单体系统，进行无限扩展。</p><p>场景说明：比如打车应用，一个集群撑不住时，分了多个集群，后来用户激增还是不够用，经过分析发现是乘客和车主访问量很大，就将打车应用拆成了三个乘客服务、车主服务、支付服务。三个服务的业务特点各不相同，独立维护，各自都可以再次按需扩展。</p><h3 id="二、前后端分离"><a href="#二、前后端分离" class="headerlink" title="二、前后端分离"></a>二、前后端分离</h3><p><strong>前后端分离原则，简单来讲就是前端和后端的代码分离也就是技术上做分离，我们推荐的模式是最好直接采用物理分离的方式部署，进一步促使进行更彻底的分离。不要继续以前的服务端模板技术，比如JSP ，把Java JS HTML CSS 都堆到一个页面里，稍复杂的页面就无法维护。</strong></p><p>这种分离模式的方式有几个好处：</p><p>1）.前后端技术分离，可以由各自的专家来对各自的领域进行优化，这样前端的用户体验优化效果会更好。</p><p>2）.分离模式下，前后端交互界面更加清晰，就剩下了接口和模型，后端的接口简洁明了，更容易维护。</p><p>3）.前端多渠道集成场景更容易实现，后端服务无需变更，采用统一的数据和模型，可以支撑前端的web UI\ 移动App等访问。</p><h3 id="三、无状态服务"><a href="#三、无状态服务" class="headerlink" title="三、无状态服务"></a>三、<strong>无状态服务</strong></h3><div align="center"><img src="https://www.waibizi.com/group1/M00/00/05/rBpUXl9N3ZOAR8AaAADd4BlIJb4271.jpg" height="50%" width="50%"></div><p>对于无状态服务，首先说一下什么是状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个“状态”数据的服务被称为有状态服务，反之称为无状态服务。</p><p>那么这个无状态服务原则并不是说在微服务架构里就不允许存在状态，表达的真实意思是要把有状态的业务服务改变为无状态的计算类服务，那么状态数据也就相应的迁移到对应的“有状态数据服务”中。</p><p>场景说明：例如我们以前在本地内存中建立的数据缓存、Session缓存，到现在的微服务架构中就应该把这些数据迁移到分布式缓存中存储，让业务服务变成一个无状态的计算节点。迁移后，就可以做到按需动态伸缩，微服务应用在运行时动态增删节点，就不再需要考虑缓存数据如何同步的问题。</p><h3 id="四、Restful通信风格"><a href="#四、Restful通信风格" class="headerlink" title="四、Restful通信风格"></a><strong>四、Restful通信风格</strong></h3><p><strong>REST的全称就是表述层状态转移（表述层状态转移），这是一套在互联网体系中，调用者与被调用者进行互动的规约设计，REST其实并不是什么新鲜事物了，早在2000年的时候Roy Thomas Fielding博士就在论文中提及了，Roy Thomas  Fielding博士是HTTP1.0与HTTP1.1协议的主要设计者，可以说REST是在HTTP交互当中的最佳规约了。</strong></p><p><strong>1.无状态协议HTTP，具备先天优势，扩展能力很强。例如需要安全加密是，有现成的成熟方案HTTPS可用。</strong></p><p><strong>2.JSON 报文序列化，轻量简单，人与机器均可读，学习成本低，搜索引擎友好。</strong></p><p><strong>3.语言无关，各大热门语言都提供成熟的Restful API框架，相对其他的一些RPC框架生态更完善。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是微服务？0202年了，你还不知道微服务？&quot;&gt;&lt;a href=&quot;#什么是微服务？0202年了，你还不知道微服务？&quot; class=&quot;headerlink&quot; title=&quot;什么是微服务？0202年了，你还不知道微服务？&quot;&gt;&lt;/a&gt;什么是微服务？0202年了，你还不
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>HTTP长短连接到TCP原理</title>
    <link href="https://waibizi.github.io/2020/07/25/HTTP%E9%95%BF%E7%9F%AD%E8%BF%9E%E6%8E%A5%E5%88%B0TCP%E5%8E%9F%E7%90%86/"/>
    <id>https://waibizi.github.io/2020/07/25/HTTP%E9%95%BF%E7%9F%AD%E8%BF%9E%E6%8E%A5%E5%88%B0TCP%E5%8E%9F%E7%90%86/</id>
    <published>2020-07-25T04:53:09.000Z</published>
    <updated>2020-07-25T04:53:36.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-长短连接介绍"><a href="#1-长短连接介绍" class="headerlink" title="1.长短连接介绍"></a>1.长短连接介绍</h2><p>HTTP短连接：客户端和服务端交互的时候每进行一次HTTP操作就建立一次连接。举例就是浏览器访问服务器去请求Web资源的时候，每请求一个Web资源，就需要建立一次连接，这个就是短连接;（HTTP/1.0默认就是短连接）</p><center>例如访问www.baidu.com这里每一个资源，如果是短连接的情况下，每一次进行HTTP操作都要重新建立一次HTTP连接</center><br><div align="center"><img src="https://www.waibizi.com/group1/M00/00/05/rBpUXl8YR0eARSFzAAIsogUix64021.png"></div><p>HTTP长连接：客户端和服务端交互的时候不会进行一次HTTP操作就建立一次连接。请求头标志就是<font color="#FF33FF">Connection: keep-alive</font>，拿上面的例子来说就是全部都是来自一次连接拿到的数据，而HTTP操作却执行了n次;</p><p>无论HTTP长连接还是短连接，本质上都是TCP连接，HTTP就是一个协议约定，HTTP是存在应用层的一个协议，而TCP是存在传输层的;</p><h2 id="2-TCP协议简单介绍"><a href="#2-TCP协议简单介绍" class="headerlink" title="2.TCP协议简单介绍"></a>2.TCP协议简单介绍</h2><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。（我们也称TCP是虚连接）</p><p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p><p>TCP也可以提供全双工的通信。（BIO与NIO就是），全双工通信有一个特点，就是有发送缓存与接收缓存</p><p>TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用4次挥手来关闭一个连接。</p><p>也就是说每一次建立连接的时候都是要经过三次握手才可以成功建立连接，而释放连接的时候需要四次挥手才可以释放连接;（意味着每一次连接都是要消耗性能跟时间的）</p><h2 id="3-TCP头部"><a href="#3-TCP头部" class="headerlink" title="3.TCP头部"></a>3.TCP头部</h2><center>由于三次握手与四次挥手涉及到TCP头部，所以我们先分析分析TCP的头部，结构图如下;</center><br><div align="center"><img src="https://www.waibizi.com/group1/M00/00/05/rBpUXl8YUueAZoGXAAJCyBT2u-o309.png" height="70%" width="70%"></div><p>TCP的头部是20个字节的固定首部，一行有四个字节，五行是固定的，四五二十字节;最后一行是可选的，填充是因为TCP有强迫症，如果选项的长度没达到四个字节，那么填充就会自动填充上去，一般都是填充0;</p><p><font color="#FF33FF">序号：</font>在一个TCP连接当中，传送的字节流中的每一个字节都是按照顺序进行编号的;</p><p><font color="#FF33FF">确认号：</font>期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，就代表序号N-1为止的所有数据都已经正确收到了;</p><p><font color="#FF33FF">数据偏移：</font>这个数据偏移主要是为了收到TCP之后，我需要将这个数据偏移多少，才能得到真正的数据。也就是TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4字节为一个单位，即1一个数值是4字节;（因为不是每一次TCP请求都是20字节固定的头部长度）</p><h3 id="重点：六大控制位"><a href="#重点：六大控制位" class="headerlink" title="重点：六大控制位"></a><font color=" #FF8C00">重点：六大控制位</font></h3><p><strong><font color="#00FA9A">紧急位URG：</font></strong>URG=1的时候，标明此报文段当中有紧急数据，是高优先级的数据，应该尽快传送，不用在缓存当中排队，要配合紧急指针字段使用;</p><p><strong><font color="#00FA9A">确认位ACK：</font></strong>ACK=1时确认号才是有效的，在连接建立之后所有传送的报文段都必须把ACK设置为1;</p><p><strong><font color="#00FA9A">推送为PSH：</font></strong>PSH=1时，接收发应该尽快交付给接收的应用程序，不再等到缓存填满了再向上交付;</p><p><strong><font color="#00FA9A">复位RST：</font></strong>RST=1时，表明TCP连接中出现了严重的差错，必须释放连接，然后重新建立传输连接;</p><p><strong><font color="#00FA9A">同步位SYN：</font></strong>SYN=1时，表明是一个连接请求/连接接受报文;</p><p><strong><font color="#00FA9A">终止位FIN：</font></strong>FIN=1时，表明此报文发送方数据已经发完了，要求释放连接;</p><p><font color="#FF33FF">窗口：</font>指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量;</p><p><font color="#FF33FF">校验和：</font>检验首部+数据，检验是要加上12字节的伪首部，第四个字段为6，表明是TCP连接;</p><p><font color="#FF33FF">紧急指针：</font>URG=1时才有意义，指出本报文段中紧急数据的字节数;</p><p><font color="#FF33FF">选项：</font>最大报文段长度MSS、窗口扩大、时间戳、选择确认等等····（这个可扩展）</p><h2 id="4-TCP连接管理"><a href="#4-TCP连接管理" class="headerlink" title="4.TCP连接管理"></a>4.TCP连接管理</h2><h3 id="TCP连接传输三部曲（三次握手）"><a href="#TCP连接传输三部曲（三次握手）" class="headerlink" title="TCP连接传输三部曲（三次握手）"></a>TCP连接传输三部曲（三次握手）</h3><div align="center"><img src="https://www.waibizi.com/group1/M00/00/05/rBpUXl8YabeAbeUtAABMW5bo56o557.png" height="50%" width="50%"></div><p>TCP连接的简历是采用<font color="#FF33FF">客户端服务端方式</font>，主动发起连接得到的应用称之为客户端，而被动等待连接建立的应用称之为服务器;</p><div align="center"><img src="https://www.waibizi.com/group1/M00/00/05/rBpUXl8YfYyAB7U9AACzrJpGn2g501.png" height="30%" width="30%"></div><center>上图歪鼻子与歪鼻子的朋友的这种对话方式其实就是TCP的连接建立过程</center><center>接下来解释三次握手！！！控制位要登场咯~</center><div align="center"><img src="https://www.waibizi.com/group1/M00/00/05/rBpUXl8YeQSARL0QAADhKO07Ph0976.png" height="70%" width="70%"></div><br><center>上图就是三次握手的过程，seq是一个序列号</center><p><font color=" #FF8C00">第一次握手：</font>客户端发送连接请求报文段，没有携带应用层数据;</p><center>SYN=1，seq=X(随机数)</center><br><p><font color=" #FF8C00">第二次握手：</font>服务器为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，没有携带应用层数据;</p><center>SYN=1 ACK=1 seq=Y (随机数) ack=X+1 </center><br><p><font color=" #FF8C00">第三次握手：</font>客户端为该TCP连接分配缓存和变量，并向故武器返回确认的确认，可以携带数据;</p><center>ACK=1 seq=X+1 ack=Y+1</center><br><p><font color=" #FF8C00">SYN洪泛攻击：</font>SYN洪泛攻击是发送在OSI第四层，也就是传输层，这种攻击是利用TCP协议的特性，即三次握手过程。攻击者发送TCP SYN，SYN是TCP三次握手当中的第一个数据报，而当服务器返回ACK后，该攻击者就不对其进行确认，那么这个TCP连接会处于挂起的状态，也就是半连接的状态，服务器如果收不到再确认的话，还会重复发送ACK给攻击者，这样会大大浪费服务器的资源。攻击者如果对服务器发送大量的这种TCP连接的话，由于每一个连接都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起而消耗CPU和内存，最后服务器可能会四级，就无法为正常用户提供服务了;</p><h3 id="TCP连接释放（四次挥手）"><a href="#TCP连接释放（四次挥手）" class="headerlink" title="TCP连接释放（四次挥手）"></a>TCP连接释放（四次挥手）</h3><center>TCP在如果需要安全得释放连接，需要经过类似下图的过程</center><br><div align="center"><img src="https://www.waibizi.com/group1/M00/00/05/rBpUXl8YfbSALWOZAADM9xNDzjY251.png" height="50%" width="50%"></div><br><p>参与一条TCP连接的两个进程当中的任何一个都可以主动终止该连接，连接结束之后，主机当中为本次连接创建的缓存与变量将会被释放;</p><div align="center"><img src="https://www.waibizi.com/group1/M00/00/05/rBpUXl8Yf4mALPHvAACb3ilmoIo442.png" height="50%" width="50%"></div><p><font color="#FF33FF">第一次挥手：</font>客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接</p><center>FIN=1 seq=u</center><br><p><font color="#FF33FF">第二次挥手：</font>服务端会送一个确认报文段，客户端到服务器这个方向的连接就已经释放了（TCP连接处于半关闭的状态）</p><center>ACK=1 seq=v ack=u+1</center><br><p><font color="#FF33FF">第三次挥手：</font>服务端发完数据，就会发出连接释放报文段，主动关闭TCP连接</p><center>FIN=1 ACK=1  seq=w ack=u+1</center><br><p><font color="#FF33FF">第四次挥手：</font>客户端会送一个确认报文段，再等待计时器设置的2MSL(最长报文段寿命)的时候后，连接就彻底关闭了;</p><center>ACK=1 seq=u+1 ack=w+1</center><br><h3 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h3><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p><h2 id="5-长连接与短连接的优缺点"><a href="#5-长连接与短连接的优缺点" class="headerlink" title="5.长连接与短连接的优缺点"></a>5.长连接与短连接的优缺点</h2><h3 id="长连接："><a href="#长连接：" class="headerlink" title="长连接："></a>长连接：</h3><p>从网页的请求角度以及到TCP的三次握手再到四次挥手，我们都可以明显感觉到长连接带来的好处，对于需要频繁请求的客户端来说，是最适合使用长连接的场景;但是，在长连接的情况下，Client一般不会主动关闭连接，这样就会导致随着Client的数量越来越多，Server端就会保持太多的连接，也会降低性能;一般我们是通过优化Server端的连接策略，如可以关闭一些长时间没有请求的客户端，这样可以避免一些恶意的连接请求，导致服务端出现连接数不够的情况。如果条件允许的话，可以限制每个客户端允许的最大连接数来达到优化的目的;</p><h3 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h3><p><strong>短连接</strong>对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户<strong>请求频繁</strong>，将在<strong>TCP的建立和关闭操作上浪费时间和带宽</strong>。</p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="彩蛋时间：涉及面试题及答案"><a href="#彩蛋时间：涉及面试题及答案" class="headerlink" title="彩蛋时间：涉及面试题及答案"></a>彩蛋时间：涉及面试题及答案</h2><h3 id="（一）为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#（一）为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="（一）为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>（一）为什么连接的时候是三次握手，关闭的时候却是四次握手？</h3><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><h3 id="（二）为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？"><a href="#（二）为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？" class="headerlink" title="（二）为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？"></a>（二）为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</h3><p>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><h3 id="（三）为什么不能用两次握手进行连接？"><a href="#（三）为什么不能用两次握手进行连接？" class="headerlink" title="（三）为什么不能用两次握手进行连接？"></a>（三）为什么不能用两次握手进行连接？</h3><p>3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p><p>​    现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><h3 id="（四）如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#（四）如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="（四）如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>（四）如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-长短连接介绍&quot;&gt;&lt;a href=&quot;#1-长短连接介绍&quot; class=&quot;headerlink&quot; title=&quot;1.长短连接介绍&quot;&gt;&lt;/a&gt;1.长短连接介绍&lt;/h2&gt;&lt;p&gt;HTTP短连接：客户端和服务端交互的时候每进行一次HTTP操作就建立一次连接。举例就是浏览器
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【Java的IO模型】BIO、NIO基础入门</title>
    <link href="https://waibizi.github.io/2020/07/12/%E3%80%90Java%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E3%80%91BIO%E3%80%81NIO%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>https://waibizi.github.io/2020/07/12/%E3%80%90Java%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E3%80%91BIO%E3%80%81NIO%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</id>
    <published>2020-07-12T07:52:38.000Z</published>
    <updated>2020-07-12T09:54:41.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、IO模型"><a href="#一、IO模型" class="headerlink" title="一、IO模型"></a>一、IO模型</h2><center>作为一个Java开发者，对于IO模型是绕不开的一环：所谓的IO模型，就是你采用什么的通道模型进行数据的接收与发送</center><center>Java的网络编程的IO模型主要有：BIO、NIO</center><center>本篇主要是学一下BIO与NIO的基础</center><h2 id="二、什么是BIO"><a href="#二、什么是BIO" class="headerlink" title="二、什么是BIO"></a>二、什么是BIO</h2><center> Java BIO英文名称是<font color="#FF33FF">Java Blocking IO</font>,顾名思义就是Java的阻塞IO模型;</center>BIO的主要特性就是同步并阻塞（传统阻塞型IO），服务器在接收到一个连接的时就会给这个连接分配线程，也就是每一个连接都需要启动一个线程进行处理;如果这个连接此时没有任何操纵的情况，只要还在连接当中的话，就会一直占用着这个线程;这里我们可以想一下，如果QQ采用的是BIO的话，那还得了嘛（嘿嘿）;<center>可是我们还是得来学一下BIO，唔····</center><center>简单看一下BIO的模型图吧</center><img src="/2020/07/12/%E3%80%90Java%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E3%80%91BIO%E3%80%81NIO%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1.jpg" class title="This is an image"><pre><code>在这个模型图当中，我们采用了四个连接，然后服务器就会去创建四个线程与客户端进行连接;</code></pre><center>那么Java的BIO在哪咧···其实就是大家Java基础经常用的</center><center>Java.io包下</center><pre><code>其实以前学网络编程的时候，这个我经常用不过我当时没有管这个叫BIO（今天废话有点多）;</code></pre><center>其实以前学网络编程的时候，这个我经常用不过我当时没有管这个叫BIO（今天废话有点多）</center><center>我们简单来看一下简单实例吧</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.waibizi;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 吴典秋</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/6 13:42</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: BIO的服务端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//采用线程池机制</span></span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor =</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor</span><br><span class="line">                        (<span class="number">8</span>,<span class="number">16</span>,<span class="number">10</span>,</span><br><span class="line">                                TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                Executors.defaultThreadFactory());</span><br><span class="line">        <span class="comment">//创建一个端口为1024的ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">1024</span>);</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"使服务器的线程名称为:"</span>+Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//监听、等待客户端的连接</span></span><br><span class="line">            System.out.println(<span class="string">"等待连接当中"</span>);</span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">"有客户端连接进来了"</span>);</span><br><span class="line">            threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class="line">                handler(socket);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"通讯的线程名称为:"</span>+Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket获取输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"进行信息交流的线程名称为:"</span>+Thread.currentThread().getName());</span><br><span class="line">                System.out.println(<span class="string">"Reading········"</span>);</span><br><span class="line">                <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span> (read!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,read));</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭与客户端的连接"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center>运行一下吧</center><br><img src="/2020/07/12/%E3%80%90Java%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E3%80%91BIO%E3%80%81NIO%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/2.jpg" class title="This is an image"><center>我们采用telnet来连接一下就可以了</center><img src="/2020/07/12/%E3%80%90Java%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E3%80%91BIO%E3%80%81NIO%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/3.jpg" class title="This is an image"><br><br><center>我这里开了三个连接，可以看到创建了三个线程了</center><center>然后再简单发几条消息康康吧</center><img src="/2020/07/12/%E3%80%90Java%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E3%80%91BIO%E3%80%81NIO%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/4.jpg" class title="This is an image"><center>然后程序你自己跑一遍，挂着康康你就晓得了</center><center>这玩意一直在连接当中···</center><center>【分析】</center>    BIO的案例分析当中，主要是每连接每线程的IO通信模型，在BIO当中serverSocket.accept()、serverSocket.read()、serverSocket.write()这三个方法都是同步阻塞的;<center>那么BIO适用于什么场景呢</center>     BIO的这种网络IO模型适用于连接数目比较小且固定的架构，这种方式对于服务器的配置要求会比较高，这种连接方式比较容易理解，在JDK1.4以前，BIO的通信方式是唯一的选择;BIO的几个要点：<p>1.每个请求都需要创建<font color="#FF33FF">独立的线程</font>，与对应的客户端进行交互;</p><p>2.当并发数比较大的时候，需要创建<font color="#FF33FF">大量的线程</font>来处理连接，</p><p>  系统资源占用比较大（别看我已经采用了线程池机制，但是一直阻塞当中的话线程池其实作用不大的）;</p><h2 id="三、什么是NIO"><a href="#三、什么是NIO" class="headerlink" title="三、什么是NIO"></a>三、什么是NIO</h2><p> Java NIO全称 <font color=" #FF8C00">Java non-blocking IO(</font>也有人称之为New IO),是Java提供的一个全新的IO模型;NIO主要是非阻塞的同步IO，BIO是阻塞的;</p><center>NIO当中主要有三大核心功能：Channel（通道）、Buffer（缓冲区）、Selector（选择器）;</center><br><br><center>【分享一个我听到十分好的比喻】</center><br><br><center>Selector是中央控制器，Buffer是承载数据的容器，而Channel可以说最基础的门面，它是本地I/O设备，网络I/O的通信桥梁，只有搭建了这座桥梁，数据才能被写入Buffer，连接才能被Selector控制;</center><br><br><center>NIO是一种非阻塞型的IO模型，也就是NIO的线程模型当中对Socket发起的连接不需要每个都创建一个线程，完全可以使用一个Selector来多路复用监听N多个Channel是否有请求，该请求是对应的连接请求，还是发送数据的请求;</center><br><br><center>这里面是基于操作系统底层的Select通知机制的，一个Selector不断的轮询多个Channel，这样避免了创建多个线程</center><br><br><center>具体模型图如下</center><br><br><img src="/2020/07/12/%E3%80%90Java%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E3%80%91BIO%E3%80%81NIO%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/5.jpg" class title="This is an image"><p>1）每一个Channel都会对应一个Buffer；</p><p>2）Select对应一个线程，一个线程对应多个Channel；</p><p>3）程序切换到哪个Channel是由事件决定的；</p><p>4）Buffer就是一个内存块，底层是有一个数组；</p><p>5）NIO当中的Buffer是可以读又可以写的，只需要flip就可以切换;</p><center>说了那么多</center><center>关于Selector、Buffer、Channel这三个概念是比较模糊的</center><center>下面具体说说这三个</center><center>【关于Selector、Buffer、Channel具体介绍】</center>**Selector**<pre><code>Selector就是一个选择器，可以选择一个通道进行通信，这样就可以不使用那么多线程去通信，具体如下：</code></pre><p>1）Java的NIO，是一种非阻塞的IO交互方式。可以用于一个线程处理多个客户端连接，采用的就是选择器的机制;</p><p>2）选择器可以监听多个已经注册的通道是否有时间发生，如果有事件发生，便获取事件然后针对每个事件进行想用的处理。这样就可以只用一个单线程去管理多个通道，也就是处理多个连接和请求;</p><p>3）采用了<font color=" #FF8C00">Selector机制</font>可以在真正有读写实践的时候，才会进行读写，就大大减少了系统的开销，不必为每个连接都创建线程，不用去维护多个线程，避免了多个线程上下文切换所带来的损耗;</p><p><strong>Channel</strong></p><pre><code>Channel的意思就是通道，有点类似与流，但是有些区的不同;</code></pre><p>1）通道可以同时进行读写操作，而流要么只能读或者只能写（可以参考FileInputStream与FileOutputStream）;</p><p>2）通道可以实现异步读写数据；</p><p>3）通道可以从<font color=" #FF8C00">缓冲区</font>读数据，也可以写入数据到缓冲当中；</p><p><strong>Buffer</strong></p><pre><code>Buffer的意思就是缓冲区，缓冲区是一个读写数据的内存块，缓冲区对象内置了一些机制，可以追踪和记录缓冲区的状态变化情况;</code></pre><p>1）Java当中提供了丰富的Buffer子类（Byte,Float,int等等）;</p><center>谈了那么多，上上代码吧，代码的注释挺多的</center><center>Server端</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.waibizi.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 歪鼻子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/12 18:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建ServerSocketChannel</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//得到一个Selector</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//绑定一个端口666，在服务器端监听</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line">        <span class="comment">//设置为非阻塞,NIO就是在这个部分可以设置为非阻塞的状态</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//把serverSocketChannel注册到selector关联，并将Channel设置为OP_ACCEPT，OP_ACCEPT表示的就是就绪状态</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">"注册后的selectionKey的数量 = "</span>+selector.keys().size());</span><br><span class="line">        <span class="comment">//循环等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//这里我们等待1秒，如果没有时间发生，则返回</span></span><br><span class="line">            <span class="keyword">if</span> (selector.select(<span class="number">1000</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"服务器等待了一秒，没有人连接"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果返回的大于0，就获取到相关的selectionKey</span></span><br><span class="line">            <span class="comment">//1. 如果返回的&gt;0， 表示已经获取到关注的事件</span></span><br><span class="line">            <span class="comment">//2. selector.selectedKeys() 返回关注事件的集合</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            System.out.println(<span class="string">"SelectionKey的数量 = "</span>+selectionKeys.size());</span><br><span class="line">            <span class="comment">//遍历Set&lt;SelectionKey&gt;，使用迭代器遍历</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext())&#123;</span><br><span class="line">                <span class="comment">//获取到SelectionKey</span></span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line">                <span class="comment">//根据key对应的通道发生的事件做相应的处理:如果key的状态是OP_ACCEPT也就是有一个连接请求</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">//调用accept这个方法，表示可以进行TCP三次握手了</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    System.out.println(<span class="string">"客户端连接成功！生成了一个socketChannel，本地连接的socketChannel的标识码是 = "</span>+socketChannel.hashCode());</span><br><span class="line">                    <span class="comment">//将SocketChannel 设置为非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//将socketChannel注册到selector，关注事件为OP_READ,同时给socketChannel</span></span><br><span class="line">                    <span class="comment">//关联到一个Buffer</span></span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                    System.out.println(<span class="string">"客户端连接了，selectionKey的数量 = "</span>+selector.keys().size());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果key的状态是OP_READ，也就是有数据发送过来了，此时需要读取客户端发送的数据了</span></span><br><span class="line">                <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">//通过key反向获取到对应的Channel</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//获取到该channel关联的buffer</span></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">int</span> read = channel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (read &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">byte</span>[] data = buffer.array();</span><br><span class="line">                        String msg = <span class="keyword">new</span> String(data).trim();</span><br><span class="line">                        System.out.println(msg);</span><br><span class="line">                        System.out.println(StandardCharsets.UTF_8.decode(buffer).toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//System.out.println("来自客户端发送的数据是："+new String(buffer.array()));</span></span><br><span class="line">                    <span class="comment">//System.out.println("UTF8转码之后"+ StandardCharsets.UTF_8.decode(buffer).toString());</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//手动从集合中移动当前的selectionKey，防止重复操作</span></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center>Client端</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.waibizi.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 歪鼻子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/18 20:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//得到一个网络通道</span></span><br><span class="line">        SocketChannel channel = SocketChannel.open();</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//提供服务器端的ip和端口</span></span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="keyword">if</span> (!channel.connect(inetSocketAddress))&#123;</span><br><span class="line">            <span class="keyword">while</span> (!channel.finishConnect())&#123;</span><br><span class="line">                System.out.println(<span class="string">"客户端可以边连接边进行其他的操作"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果连接成功，就开始发送数据</span></span><br><span class="line">        String msg = <span class="string">"歪鼻子已就位!"</span>;</span><br><span class="line">        <span class="comment">//将发送数据以字节的形式写入到buffer当中</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">        <span class="comment">//将buffer写入到channel当中</span></span><br><span class="line">        channel.write(buffer);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.waibizi.group;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 歪鼻子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/7/9 16:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientA</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 服务的IP地址 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="comment">/* 服务的端口 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">2048</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientA</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/* 打开选择器 */</span></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">/* 连接服务器 */</span></span><br><span class="line">        socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(HOST,PORT));</span><br><span class="line">        <span class="comment">/* 设置为非阻塞状态 */</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">/* 将通道注册到选择器上 */</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        name = <span class="string">"ClientA"</span>;</span><br><span class="line">        System.out.println(name+<span class="string">" is ok····"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String info)</span></span>&#123;</span><br><span class="line">        info = name + <span class="string">"说："</span>+info;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (selector.select()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">/* 得到相关的通道 */</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">/* 得到一个buffer */</span></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="comment">/* 读取 */</span></span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(buffer.array()).trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/* 启动客户端 */</span></span><br><span class="line">        ClientA client = <span class="keyword">new</span> ClientA();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    client.read();</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">3000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">/* 向客户端发送数据 */</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">            String msg = scanner.nextLine();</span><br><span class="line">            client.send(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center>Server端打印情况</center>{% asset_img 6.jpg This is an image %}<center>简单小案例（群聊系统）</center><br><center>截图效果先</center><br><center>服务端</center><br>{% asset_img 7.jpg This is an image %}<center>客户端A</center>{% asset_img 8.jpg This is an image %}<center>客户端B</center>{% asset_img 9.jpg This is an image %}<center>服务端代码（注释同样很丰富，为了方便有截图行号）</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.waibizi.group;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 歪鼻子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/7/9 14:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 群聊天，服务端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 定义属性 */</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化服务端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/* 打开选择器 */</span></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">/* 打开通道 */</span></span><br><span class="line">        listenChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">/* 绑定端口 */</span></span><br><span class="line">        listenChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">        <span class="comment">/* 设置为非阻塞状态 */</span></span><br><span class="line">        listenChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">/* 将通道注册到选择器当中（注意：注册的状态应该是接受的状态） */</span></span><br><span class="line">        listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">/* 如果选择器有事件需要处理，也就是选择器的选择大于0 */</span></span><br><span class="line">            <span class="keyword">if</span> (selector.select()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">/* 遍历得到所有的selectedKey（每个Channel向Selector注册时,都将会创建一个selectionKey） */</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                    <span class="comment">/* 取出selectionKey */</span></span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="comment">/* 监听到key的状态为accept */</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        SocketChannel sc = listenChannel.accept();</span><br><span class="line">                        <span class="comment">/* 将通道收到的socketChannel设置为非阻塞状态 */</span></span><br><span class="line">                        sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                        <span class="comment">/* 将该socketChannel注册到selector并设置为状态read */</span></span><br><span class="line">                        sc.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                        System.out.println(<span class="string">"地址是"</span>+sc.getRemoteAddress().toString().substring(<span class="number">1</span>)+<span class="string">"的用户上线了"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* 如果通道是read事件，即通道是可读状态 */</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                        read(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* 移除已经处理过的selectionKey */</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key读取消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/* 得到Key当中的channel */</span></span><br><span class="line">        channel = (SocketChannel) key.channel();</span><br><span class="line">        <span class="comment">/* 创建缓冲区 */</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">/* 如果读取到数据 */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel.read(buffer)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">/* 把缓冲区的数据转成字符串 */</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                System.out.println(<span class="string">"来自客户端的消息："</span>+msg.trim());</span><br><span class="line">                <span class="comment">/* 向除了自己的其他客户端转发消息 */</span></span><br><span class="line">                sendInformationToOther(msg,channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">" 离线了.."</span>);</span><br><span class="line">                <span class="comment">/* 取消注册 */</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">/* 关闭通道 */</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException ee)&#123;</span><br><span class="line">                ee.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInformationToOther</span><span class="params">(String msg,SocketChannel self)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器转发消息中······"</span>);</span><br><span class="line">        <span class="comment">/* 遍历所有注册到选择器的Socket并且排除自己 */</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey key:selector.keys())&#123;</span><br><span class="line">            <span class="comment">/* 通过key取出channel */</span></span><br><span class="line">            Channel target = key.channel();</span><br><span class="line">            <span class="keyword">if</span> (target <span class="keyword">instanceof</span> SocketChannel &amp;&amp; target != self)&#123;</span><br><span class="line">                SocketChannel dest = (SocketChannel)target;</span><br><span class="line">                <span class="comment">/* 将msg存储到buffer */</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">/* 将buffer的数据写入到通道当中 */</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server();</span><br><span class="line">        server.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center>Client（由于客户端A与B的代码几乎是一致的，所以就只放一个）</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.waibizi.group;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 歪鼻子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/7/9 16:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientA</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 服务的IP地址 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="comment">/* 服务的端口 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">2048</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientA</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/* 打开选择器 */</span></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">/* 连接服务器 */</span></span><br><span class="line">        socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(HOST,PORT));</span><br><span class="line">        <span class="comment">/* 设置为非阻塞状态 */</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">/* 将通道注册到选择器上 */</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        name = <span class="string">"ClientA"</span>;</span><br><span class="line">        System.out.println(name+<span class="string">" is ok····"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String info)</span></span>&#123;</span><br><span class="line">        info = name + <span class="string">"说："</span>+info;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (selector.select()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">/* 得到相关的通道 */</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">/* 得到一个buffer */</span></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="comment">/* 读取 */</span></span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(buffer.array()).trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/* 启动客户端 */</span></span><br><span class="line">        ClientA client = <span class="keyword">new</span> ClientA();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    client.read();</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">3000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">/* 向客户端发送数据 */</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">            String msg = scanner.nextLine();</span><br><span class="line">            client.send(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、从传统拷贝到零拷贝"><a href="#四、从传统拷贝到零拷贝" class="headerlink" title="四、从传统拷贝到零拷贝"></a>四、从传统拷贝到零拷贝</h2><center>我们先来看看传统的文件IO</center><br>{% asset_img 10.jpg This is an image %}<p>（1）read() syscall ：java客户端（jvm虚拟机）向操作系统</p><pre><code>发起读磁盘数据的请求;</code></pre><p>（2）ask for data ：系统向磁盘读数据;</p><p>（3）data to kernel buffer through DMA： 磁盘数据通过</p><pre><code>DMA读到内核缓存区</code></pre><p>（4）data to kernel buffer through DMA： 磁盘数据通过</p><pre><code>DMA读到内核缓存区</code></pre><p>（5）code logic coutinues：业务逻辑处理</p><p>（6）wirte() syscall,copies data to kernel socket </p><pre><code>buffer：客户端向系统发起写请求，并且把用户缓冲区数据复制到内核缓冲区&lt;br/&gt;</code></pre><p>从<font color=" #FF8C00">用户态与内核态</font>角度分析</p><p>read() syscall：从用户态切换为内核态</p><p>copy data to user buffer：从内核态切换为用户态</p><p>wirte() syscall,copies data to kernel socket buffer：从用户态切换为内核态</p><p>write() returns：从内核态切换为用户态</p><p>从整体得到角度看，一次IO操作进行了四次用户空间与内核空间的上下文切换，以及四次的数据拷贝（用户拷贝到内核，内核拷贝到用户）;我们在传统的IO当中可以看到，从内核拷贝到用户是没必要的，就是在消耗性能，于是提出了零拷贝机制</p><center>（传统的InputStream与OutputStream就是传统IO）</center><center>Linux2.4之前零拷贝机制</center><img src="/2020/07/12/%E3%80%90Java%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E3%80%91BIO%E3%80%81NIO%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/11.jpg" class title="This is an image"><p>2.4之前的零拷贝用户与内核上下文切换有两次</p><p>（1）sendfile() syscall：从用户态切换为内核态</p><p>（2）sendfile() returns：从内核态切换为用户态</p><p>2.4之前的零拷贝数据拷贝有三次</p><p>data to kernel buffer through DMA：磁盘数据通过DMA读到内核缓存区</p><p>wirte data to target socket buffer：从内核空间缓冲区写到socket缓冲区</p><p>从内核空间缓冲区写到socket缓冲区：socket向目标发送数据</p><p>（Linux2.4之前的零拷贝是把 kernel buffer 中全部的数据 拷贝到socket buffer）</p><p>在Linux2.4之后对于零拷贝进行了优化，对于之前的kernel buffer拷贝全部数据优化成了拷贝地址和数据长度（这部分的数据量小到可以忽略不计），当需要真正使用数据的时候，客户端会从socket buffer当中拿到地址与长度，然后到达kernel buffer当中去索取数据进行操作;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、IO模型&quot;&gt;&lt;a href=&quot;#一、IO模型&quot; class=&quot;headerlink&quot; title=&quot;一、IO模型&quot;&gt;&lt;/a&gt;一、IO模型&lt;/h2&gt;&lt;center&gt;作为一个Java开发者，对于IO模型是绕不开的一环：所谓的IO模型，就是你采用什么的通道模型进行数
      
    
    </summary>
    
    
      <category term="-BIO、NIO" scheme="https://waibizi.github.io/categories/BIO%E3%80%81NIO/"/>
    
    
      <category term="-IO模型" scheme="https://waibizi.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>synchronized锁升级分析</title>
    <link href="https://waibizi.github.io/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/"/>
    <id>https://waibizi.github.io/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/</id>
    <published>2020-06-24T09:17:30.000Z</published>
    <updated>2020-07-13T05:49:41.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Mutex介绍"><a href="#1-Mutex介绍" class="headerlink" title="1.Mutex介绍"></a>1.Mutex介绍</h2><p>  <font color=" #FF8C00">Mutex</font>中文名称是<font color="#00FA9A">互斥锁</font>，跟着中文名称很好理解了，就是为了互斥;<br></p><p>  在并发的情况下，对于一个对象的操作，可能会导致数据不一致性问题，为了保证共享数据操作的完整性。每个对象都对应于一个可称为” 互斥锁” 的标记，这个标记用来保证在任一时刻，只能有<font color="#00FA9A">一个线程</font>访问该对象；<br></p><h2 id="2-经典问题引入"><a href="#2-经典问题引入" class="headerlink" title="2.经典问题引入"></a>2.经典问题引入</h2><p>  前言：<font color="#FF33FF">synchronized</font>是获取锁对象！！！是一个操作，将锁对象加到代码上面;（这句话多记几遍，不然下面会踩坑） <br></p><p>  下面这段代码，创建了1000条线程去执行一个static的变量，每一条线程使的count加一，为了使问题更加明显，这里让线程在count++之前，睡眠了一毫秒。在打印输出结果之前，再让主线程睡眠三秒，保证所有线程都执行完再打印数据;原本预期结果是1000，按照正常逻辑也应该是1000.其实不然，每个电脑的结果不同，你自己试着跑一遍吧。<br></p><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/1.jpg" class title="This is an image"></center><br><p>  打印出来肯定不是1000，根据<font color=" #FF8C00">JMM的模型</font>，可以推断是工作内存的变量没有同步到主内存当中。<br></p><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/2.jpg" class title="This is an image"></center><br><center>采用synchronized给当前对象加锁，打印结果是1000</center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/3.jpg" class title="This is an image"></center><br><p>通过字节码分析，可以看到同步的部分是使用<font color="#00FA9A">monitorenter和monitorexit指令</font>。这两个指令隐式地执行了mutex的lock和unlock操作，用于提供原子性的操作;</p><p>  这两个指令的命名也有有原因的，原则上他们是获取了这个对象的<font color=" #FF8C00">监视器（monitor）</font>,这个过程是排他的，也就是说同一时刻只有一个对象能获取到由synthronized保护的对象;<br></p><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/4.jpg" class title="This is an image"></center><br><center>好了，我们加上<font color=" #FF8C00">synchronized</font>修饰，运行结果是1000毫无疑问的</center><br><h2 id="3-深入了解synchronized"><a href="#3-深入了解synchronized" class="headerlink" title="3.深入了解synchronized"></a>3.深入了解synchronized</h2><p>  首先明确一下我们只需要关注<font color="#00FA9A">对象头</font>的此处位置三个数字，这个地方是对象的锁状态（下面这张图只是举例说明看哪）；<br></p><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/5.jpg" class title="This is an image"></center><br><center>然后我们只需关于这些状态</center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/6.jpg" class title="This is an image"></center><br><center>先来看下锁升级的流程图</center>  <br><p>  在Java SE1.6的时候对于synchronized进行了优化，也就是synchronized在加锁的时候，里面关于锁的机制进行升级，升级的过程如下流程图：<br></p><center>（以下都是加了synchronized的时候进行分析的结果）</center><br><center>当线程第一次访问这个对象时</center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/7.jpg" class title="This is an image"></center><br><p>解释：线程一访问到synchronized代码块的时候，先检查对象的标记位，第一次进来的线程肯定不会读到标记检查，就将对象占有，进行标记，然后执行代码块，执行完成之后不会清除对象的标记。（这个过程是偏向锁的过程）<br></p><center>当有第二个线程接着访问此对象的时候</center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/8.jpg" class title="This is an image"></center><br><p>解释：当第二个线程访问到synchronized代码块的时候，检查到有标记（因为上一个对象不会清除），判断上一个对象是否存活，如果不存活了，则跟第一个线程进来一样的步骤，如果存活，则进入到<font color=" #FF8C00">轻量级锁</font>，也就是<font color="#00FA9A">锁自旋</font>；如果自旋太久了了，也就是大于十次了，就转移到<font color="#00FA9A">重量级锁</font>，将线程挂起；<br></p><h2 id="4-synchronized锁验证"><a href="#4-synchronized锁验证" class="headerlink" title="4.synchronized锁验证"></a>4.synchronized锁验证</h2><center>无锁状态</center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/9.jpg" class title="This is an image"></center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/10.jpg" class title="This is an image"></center><br><center>偏向锁</center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/11.jpg" class title="This is an image"></center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/12.jpg" class title="This is an image"></center><br><center>解释：因为JVM底层进行加载的时候，会将延时加载的对象加上偏向锁;</center><br><center>注意：此时的偏向锁是一种特殊的偏向锁，具体往下看</center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/13.jpg" class title="This is an image"></center><br><p>在对象头的位置上，我们可以看到线程ID此时其实是全为零的，再结合偏向锁的概念，偏向锁，偏向、偏向…其实就是偏向了某个线程，此时不偏向其他线程，也可以理解这个就是一个特殊的“无锁”；<br></p> <center>那么怎么让他<font color="#00FA9A">偏向</font>呢？</center> <center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/14.jpg" class title="This is an image"></center><center>上图的代码可以让这把锁进行偏向</center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/15.jpg" class title="This is an image"></center><br><center>可以看到依然是偏向锁的情况下，有了偏向的线程ID了</center><br><center>注意：你要讲访问的对象加synchronized修饰才有这种效果</center><br><center>自旋锁(轻量级锁)</center><br><p>  自旋锁是自我上锁了，这个自我上锁的条件，是上一个线程还存活，那么就想办法让线程存活的情况下，再执行一条线程；<br></p><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/16.jpg" class title="This is an image"></center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/17.jpg" class title="This is an image"></center><br><p>在主线程不在睡眠直接加载类的情况下，JVM不底层没有触碰到stu的synchronized代码片段，但是在创建第二个线程创建的时候，JVM底层触碰到了stu的synchronized代码片段，导致了中间会变化了偏向锁，然后根据流程图，第二个线程访问这个具有偏向锁，且第一个线程为消亡的情况下（在main线程当中创建了另外一个线程，main线程肯定还不会消亡），会将偏向锁改为轻量级锁（自旋锁）。<br></p><p>ps:JVM中间转换过程目前能力原因找不到方法去证明，这是一个推断的想法。如果你有方法证明，可以联系一下我吗？<br></p><center>重量级锁</center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/18.jpg" class title="This is an image"></center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/19.jpg" class title="This is an image"></center><br><p>  自旋状态还没结束，就会导致不断去自旋，自旋次数超过十了，就会将锁机制转换到重量级锁，这个过程可能比较麻烦去验证，这里主要是证明锁的存在，以及验证什么情况会产生不同的锁。<br></p><center>【小结】</center><br><p>  synchronized在这此笔记当中只是简单了验证了锁升级，以及synthronized的简单了解。关于synthronized还有<font color="#FF33FF">很多很多</font>需要学习的，锁的加锁过程怎么去debug，发现升级过程这些的，还需要好好加强<br></p><center>【题外话】</center><br><p>因为有点好奇延迟加载究竟延迟加载多久才加锁，在我自己电脑进行了测试，在写文章的时候是睡眠了这个值，也就是在我自己电脑上，睡眠了这么长的时间情况下，多运行几次会产生在无锁与偏向锁的切换，有兴趣的小伙伴可以自行尝试，然后在下方留言（这个对我有帮助哦，谢谢你啦）<br></p><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/20.jpg" class title="This is an image"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Mutex介绍&quot;&gt;&lt;a href=&quot;#1-Mutex介绍&quot; class=&quot;headerlink&quot; title=&quot;1.Mutex介绍&quot;&gt;&lt;/a&gt;1.Mutex介绍&lt;/h2&gt;&lt;p&gt;  &lt;font color=&quot; #FF8C00&quot;&gt;Mutex&lt;/font&gt;中文名称是
      
    
    </summary>
    
    
      <category term="-Java锁" scheme="https://waibizi.github.io/categories/Java%E9%94%81/"/>
    
    
  </entry>
  
  <entry>
    <title>【并发基础】Java当中的几个锁概念</title>
    <link href="https://waibizi.github.io/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/"/>
    <id>https://waibizi.github.io/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/</id>
    <published>2020-06-14T16:55:30.000Z</published>
    <updated>2020-06-14T18:13:49.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>  Java对于并发场景，对于锁的使用是最重要的，这次主要是介绍一下Java当中的锁类别与场景：公平锁、非公平锁、乐观锁、悲观锁、偏向锁、轻量级锁、重量级锁、自旋锁、读写锁、锁粗化/锁消除、分段锁;</p><h2 id="2-公平锁与非公平锁"><a href="#2-公平锁与非公平锁" class="headerlink" title="2.公平锁与非公平锁"></a>2.公平锁与非公平锁</h2><p>  正如锁的名字所言，他们的要点就是在于公平或者非公平的这两个意思身上;</p><p>  假设我们有如下场景，Thread-1获得锁之后，其他线程如果需要获得锁，不管是公平还是非公平都是需要在外等待的;</p><center><font color=" #FF8C00">（注意，这里Thread-2到Thread-4是依次到达来等待锁的）</font></center><p>  那么接下来的场景就是体现公平锁跟非公平锁的时候了，Thread-1已经释放锁了，而剩下的几个线程都需要这个锁，那么应该怎么去分配锁呢？</p><p>  如果是公平锁，那么就是多来了一个线程，也得去队列当中待着，按照线程来竞争锁的顺序一个一个排队;</p><p>  如果是非公平锁的话，在Thread-2到Thread-4之间，他们去竞争这把锁的机会是同等的，也就是他们不用排队等待，谁竞争到了就先持有锁;</p><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/1.jpg" class title="This is an image"></center><p>实现例子：</p><p>注意：你需要了解<b><font color=" #FF8C00">ReentrantLock</font></b>的一些常识，例如这是一个可重入的锁，而且默认是非公平锁;</p><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/2.png" class title="This is an image"></center><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/3.png" class title="This is an image"></center><center>然后我们运行一下吧</center><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/4.png" class title="This is an image"></center><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/5.png" class title="This is an image"></center><center>我们开始start的时候，肯定是外部线程先进去等待了</center><center>然后再内部锁进去了等待，那么如果是公平锁</center><center>就是大家一起按顺序慢慢等</center><center>那么非公平肯定就没有顺序的啦</center><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/6.png" class title="This is an image"></center><center>这个位置改一下</center><center>然后再次运行就可以看到内部与外部的输出是交替的</center><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/7.png" class title="This is an image"></center><center>我这里就随便截图一个输出就行了</center><center>可以看到是交替的进行的</center><center>也就是不用按照线程去竞争锁的排队顺序的</center><center>大多数锁机制都是默认为非公平锁的</center><center>因为非公平锁有着比公平锁更好的性能</center><center>由于线程的上下文切换浪费性能</center><center>以及需要等待排队线程的唤醒操作等等都会影响浪费性能</center><h2 id="3-读写锁"><a href="#3-读写锁" class="headerlink" title="3.读写锁"></a>3.读写锁</h2><p>  大多数的人刚开始接触的锁其实都是属于排他锁，也就是线程独占锁，一旦线程占有这把锁的话，其他线程的任何操作想获取锁都是没办法获取的;</p><p>  然而在一些特定的场景下，我们并不希望一旦一个线程占有了这个锁，就无法进行其他的操作;</p><p>  <b><font color=" #00FA9A">读写锁</font></b>：也就是读写锁分离。读锁可以在没有写锁的时候，被多个线程共同占用，而写锁是独占的，也就是只能由一个线程去占用这把锁;</p><center>互斥的原则是</center><center>多个线程都是读的时候，都是可以共同持有锁</center><center>有一个写操作的时候，其他线程<font color=" #00FA9A">不能读也不能写</font></center><center>这里我们模拟一个队列，队列里面有写入操作与读取操作</center><center>在写入操作与读取操作的时候，我们分别加上写锁与读锁</center><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/8.png" class title="This is an image"></center><center>编写main方法测试</center><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/9.png" class title="This is an image"></center><center>我们从前面的理论知识推断，在读取的时候，</center><center>写操作是不能<font color=" #FF8C00">直接插入</font>的，因为是<b><font color=" #FF8C00">互斥的</font></b></center><center>也就是写操作的时候，必须在某一个时机</center><center>恰好！！读操作释放了锁，写操作接着占用了这把锁</center><center><font color=" #FF8C00">看下运行结果吧</font></center><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/10.png" class title="This is an image"></center><center>上面的demo只是为了验证锁</center><center>我们学习东西主要是为了使用</center><center>这个锁在缓存场景其实很适用的</center><p>回顾一下我们的缓存场景：不就是写的操作比较少，读的情况比较多，我们为了提高速度将缓存放置到内存当中嘛？</p><p>为了方便模拟的策略，我们先说一下我们要实现的一个小例子：我们模拟在缓存场景下，如果值存在，我们就直接get返回，并且这个get操作是多个线程可以共享的;如果值不存在的情况，多个线程只能有一个线程去获取到锁，并且触发查询数据库的操作;</p><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/11.png" class title="This is an image"></center><h2 id="4-自旋锁"><a href="#4-自旋锁" class="headerlink" title="4.自旋锁"></a>4.自旋锁</h2><p>  有的时候我们加上一些lock操作的时候，会导致上下文切换浪费性能，因为需要上锁再释放锁，有一些持有锁的时间比较短的情况下，我们可以采用<b><font color=" #00FA9A">自旋锁</font></b>;</p><p>  <b><font color=" #00FA9A">自旋锁</font></b>，顾名思义，自我“旋转”就变成了锁，这个自我旋转指的是去旋转CPU的时间片，不上锁的情况让线程在那里进行空转;</p><p>我们简单看一下需求，如果说主线程的那句打印，我们需要在所有的线程执行完毕之后再开始执行的话，不加lock的情况，我们应该怎么去操作;</p><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/12.png" class title="This is an image"><center>上面代码的执行时打印这样，还没有加自旋锁的情况的</center><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/13.png" class title="This is an image"></center><p>这里由于我的编码工具的缘故，所以我自旋的时候判断线程数目采用了2，不过这不是关键啦，主要是看下自旋的思想</p><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/14.png" class title="This is an image"></center><h2 id="5-偏向锁"><a href="#5-偏向锁" class="headerlink" title="5.偏向锁"></a>5.偏向锁</h2><p>  <b><font color=" #FF8C00">偏向锁</font></b>，在synchronized锁升级时候，有去看到锁升级的采用了偏向锁，至于偏向锁怎么去实现，笔者暂时不清楚怎么去实现;</p><p>  <b><font color=" #00FA9A">偏向锁</font></b>主要用于大多数情况是一个线程去竞争这把锁的情况，也就是这个锁在大多数情况下，只有一个线程去多次获得。一旦有多个线程来<b><font color=" #00FA9A">竞争锁</font></b>了，偏向锁都会升级为其他锁的;</p><h2 id="6-其他几个锁的概念"><a href="#6-其他几个锁的概念" class="headerlink" title="6.其他几个锁的概念"></a>6.其他几个锁的概念</h2><p>  <b><font color=" #FF8C00">悲观锁</font></b>：例如synchronized加锁的情况，就是属于悲观锁，悲观锁，顾名思义，就是比较悲观，每一次我们都必须加锁;</p><p>  <b><font color=" #FF8C00">乐观锁</font></b>：就是比较少竞争的情况，我们没有进行加锁操作，如果竞争比较严重的时候，我们就对其进行加锁，这个取决于你怎么去实现;</p><p>  <b><font color=" #FF8C00">重量级锁</font></b>：synchronized就是一把重量级锁，但是synchronized没有那么低效率了，锁升级的过程让synchronized这把有着重量级锁的性能得到了提升;</p><p>  <b><font color=" #FF8C00">轻量级锁</font></b>：当偏向锁升级成轻量级锁的时候，我们称这种机制是轻量级锁;</p><p>  <b><font color=" #FF8C00">分段锁</font></b>：并发包下，例如常见的ConcurrentHashMap里面就采用了分段锁，主要是根据锁的位置不是大面积的情况，进行分段加锁;</p><p>  <b><font color=" #FF8C00">锁粗化</font></b>：如果说加锁位置是一大块的位置，没有更细粒度去加锁位置的话，就是锁粗化;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h2&gt;&lt;p&gt;  Java对于并发场景，对于锁的使用是最重要的，这次主要是介绍一下Java当中的锁类别与场景：公平锁、非公平锁、乐观锁、悲
      
    
    </summary>
    
    
      <category term="-Java并发" scheme="https://waibizi.github.io/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="-锁机制" scheme="https://waibizi.github.io/tags/%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>【线程通信】生产者消费者模型</title>
    <link href="https://waibizi.github.io/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <id>https://waibizi.github.io/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-06-11T17:44:11.820Z</published>
    <updated>2020-06-11T18:14:06.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-生产者消费者模型介绍"><a href="#1-生产者消费者模型介绍" class="headerlink" title="1.生产者消费者模型介绍"></a>1.生产者消费者模型介绍</h2><p>  <font color=" #FF8C00">生产者消费者模型，</font>是每一个学习多线程的的人都需要知道的模型;</p><p>大致情况就是：有两个线程，一个负责生产产品，一个消费产品，两者公用同一块内存区域，也就是产品放在了同一块内存上面，如果两个线程没有采用一定的措施或者采用的策略错误的情况下，容易出现一系列的问题，例如数据一致性问题，死锁问题;</p><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/1.png" class title="This is an image"><h2 id="2-为什么需要生产者消费者模型"><a href="#2-为什么需要生产者消费者模型" class="headerlink" title="2.为什么需要生产者消费者模型"></a>2.为什么需要生产者消费者模型</h2><p>  在多线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程;如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据;同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者;为了解决这个问题于是引入了生产者和消费者模式。</p><h2 id="3-生产者-消费者模型（线程阻塞，线程唤醒）"><a href="#3-生产者-消费者模型（线程阻塞，线程唤醒）" class="headerlink" title="3.生产者-消费者模型（线程阻塞，线程唤醒）"></a>3.生产者-消费者模型（线程阻塞，线程唤醒）</h2><p>  举例：线程1去奶茶，没有奶茶了，它就不执行了;线程二生产奶茶，通知线程1继续执行;</p><p>下面这个例子不大好，使用了Java线程已经抛弃的方法</p><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/2.png" class title="This is an image"><p>打印结果如下，最开始没奶茶，后来有了奶茶通知了挂起的线程，那个线程就得以继续执行</p><center><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/3.png" class title="This is an image"></center><p>上面这个就是经典的生产者-消费者模型，但是为啥这个例子当中的线程方法被弃用了呢？往下看一个例子</p><center>suspend和resume加锁导致死锁</center><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/4.png" class title="This is an image"><center>打印结果</center><center><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/5.png" class title="This is an image"></center><p>这个线程不用等了，一直都是在这里挂起了，竞争不到锁，没办法通知挂起的线程继续执行;</p><p>如果suspend比resume慢执行，也会导致线程永久挂起</p><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/6.png" class title="This is an image"><center>打印结果，通知完了，那边才开始挂起</center><center><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/7.png" class title="This is an image"></center><center>那么Java现在推荐哪一种方式进行使用呢~</center><center>wait/notify机制</center><p>这个机制要求这两个方法只能由同一对象锁的持有者线程进行调用，也就是卸载同步代码块里面，否则会抛出</p><center>IllegalMonitorStateException异常</center><p>wait方法导致当前的线程进入等待状态，加入该对象的等待集合中，并发放弃当前持有的对象锁;</p><p>notify/notifyAll方法唤醒一个或所有正在等待这个对象锁的线程;</p><p>注意：虽然会wait自动解锁，但是对顺序有要求，如果在notify被调用之后才开始wait方法的调用，线程会永远处于WAITING状态</p><center>先来一个正常的演示（打印跟前面正常的一致）</center><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/8.png" class title="This is an image"><center>可以看到，如果是suspend/resume的话，这个程序是会导致死锁的，可是这里采用的是wait/notify机制，会自动释放锁</center><center>如果notify比waiting先执行</center><center>那么会导致线程一直处于WAITING的状态</center><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/9.png" class title="This is an image"><center></center>说个题外话，我觉得这个就跟你的女神已经通知你，我们不可能在一起了，然后你还一直在等待<center>还有另外一个机制</center><center><font color=" #FF8C00">park/unpark机制</font></center><center>park表示等待一个“许可”</center><center>unpark表示授予一个"许可"</center><center>park/unpark机制有一个好处就是如果提前颁发“许可”了</center><center>也不会导致线程一直处于挂起或者是死锁的转态</center><center>但是它不会主动去释放锁</center><center>unpark比park提前执行的例子</center><center><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/10.png" class title="This is an image"></center><center>加锁导致死锁的例子</center><center><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/11.png" class title="This is an image"></center><center><font color=" #00FA9A">【总结】</font></center><center><font color=" #FF8C00">suspend/resume机制</font></center><center>resume先执行，suspend慢执行;resume/suspend加锁;都会导致死锁</center><center>wait/notify机制</center><center>wait/notify加锁了会自动释放锁，但是notify比wait先执行依然会线程永久挂起</center><center><font color=" #FF8C00">park/unpark机制</font></center><p>park/unpark不会自动释放锁，但是先后执行顺序不会导致线程永久挂起</p><center><font color=" #FF8C00">【提醒】</font></center><center><font color=" #FF8C00">代码当中使用if语句来判断是否进入等待状态</font></center><center>是错误的</center><center>官方建议是采用<font color="#00FA9A">while</font>情况下，判断是否可以将线程挂起</center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-生产者消费者模型介绍&quot;&gt;&lt;a href=&quot;#1-生产者消费者模型介绍&quot; class=&quot;headerlink&quot; title=&quot;1.生产者消费者模型介绍&quot;&gt;&lt;/a&gt;1.生产者消费者模型介绍&lt;/h2&gt;&lt;p&gt;  &lt;font color=&quot; #FF8C00&quot;&gt;生产者消费
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【Java设计模式】代理模式</title>
    <link href="https://waibizi.github.io/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://waibizi.github.io/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-10T18:21:31.000Z</published>
    <updated>2020-06-10T18:36:11.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java代理模式的基本介绍"><a href="#1-Java代理模式的基本介绍" class="headerlink" title="1.Java代理模式的基本介绍"></a>1.Java代理模式的基本介绍</h2><p>  首先得跟大家说明白，本篇文章的设计模式实现是基于<font color="#00FA9A">Java语言</font>的，思想还是代理的思想，不要纠结于我为什么将静态代理，动态代理，cglib代理分开来说（只能说技术是技术，思想是思想）</p><p><font color=" #FF8C00">代理模式：</font>为一个对象提供一个替身，以控制对这个对象的访问;即通过代理对象访问目标对象;这样做的好处是可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能;</p><p>被代理的对象可以是<font color=" #FF8C00">远程的对象</font>、开销大的对象或者需要被安全控制保护的对象;</p><p>Java的手段实现代理模式的手段主要有三种：<font color="#00FA9A">静态代理，动态代理（JDK代理、接口代理）和cglib代理（cglib代理主要是可以在内存中创建对象，不用实现接口）</font></p><center>代理模式的类图如下</center><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/1.png" class title="This is an image"><p>  我们要调用<font color="#00FA9A">TargetObject类</font>，也就是目标类的时候，我们（Client）采用调用代理(ProxyObject)的方式去调用最终目标类，进而达到隐藏真正目标类</p><h2 id="2-Java实现静态代理"><a href="#2-Java实现静态代理" class="headerlink" title="2.Java实现静态代理"></a>2.Java实现静态代理</h2><p>静态代理：静态代理在使用的时候，需要定义接口或者是父类，被代理对象（即目标对象TargetObject）与代理对象（ProxyObject）一起实现相同的接口或者是继承相同的父类</p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/2.png" class title="This is an image"><p>类图的意思：假如我是客户（Client）我要去租房，我找到了租房中介（RentingProxy），租房中介与房东（Renting）之间签订了一定的约束，也就是条约。这是采用IRenting来约束;然后我需要租房的时候，只需要找到租房中间去租房就行了，我知道我要租哪间房，我直接调用租房中介有的方法，而租房中介可以帮我处理一些增强方法，例如会提前帮我去看房子合不合格之类的（称之为增强方法）;</p><p>代码如下：</p><center>包结构</center><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/3.png" class title="This is an image"><p>客户端类，创建了目标对象，创建了代理对象，然后将目标对象交付给代理对象，使用代理对象执行方法;</p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/4.png" class title="This is an image"><center>目标对象与代理对象应该遵守的合约</center><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/5.png" class title="This is an image"><center><font color="#00FA9A">目标对象</font></center><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/6.png" class title="This is an image"><p>代理对象，我们可以做一些增强操作</p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/7.png" class title="This is an image"><p>Client启动，执行main方法打印</p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/8.png" class title="This is an image"><h2 id="3-JDK代理"><a href="#3-JDK代理" class="headerlink" title="3.JDK代理"></a>3.JDK代理</h2><p>这里顺便介绍一下动态代理</p><p>1.代理对象，不需要实现接口，但是目标对象需要实现接口，</p><p> 否则不能使用动态代理</p><p>2.代理对象的生成，是利用了JDK的API，动态地在内存中构建</p><p> 对象</p><p>3.动态代理也叫：<font color=" #FF8C00">JDK代理、接口代理</font></p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/9.png" class title="This is an image"><p>采用的案例还是上面那个租房子的案例</p><center><font color=" #FF8C00">包结构</font></center><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/10.png" class title="This is an image"><center><font color=" #FF8C00">Client类</font></center><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/11.png" class title="This is an image"><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/12.png" class title="This is an image"><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/13.png" class title="This is an image"><p>这里的JDK动态代理可能会比较难懂，参数的意义我已经加上了</p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/14.png" class title="This is an image"><h2 id="4-Cglib代理"><a href="#4-Cglib代理" class="headerlink" title="4.Cglib代理"></a>4.Cglib代理</h2><p>1.静态代理和JDK动态代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可使用目标对象子类来实现代理，这就是Cglib代理;</p><p>2.Cglib代理也叫子类代理，他是在内存中构建一个子类对象从而实现对象功能扩展;</p><p>3.Cglib是一个强大的高性能代码生成包，可以在运行期间扩展Java类与实现Java接口;广泛地被许多AOP框架所使用，例如Spring AOP，实现方法拦截;</p><p>4.AOP编程当中应该如何选择代理模式</p><p>  1）.目标对象需要实现接口，用JDK代理</p><p>  2）.目标对象不需要实现接口，用Cgglib代理</p><p>5.Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类</p><center><font color=" #FF8C00">【注意】</font></center><p>需要代理的类也就是目标类不能使用final修饰</p><p>如果目标类的方法是static/final修饰的，也不能</p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/15.png" class title="This is an image"><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/16.png" class title="This is an image"><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/17.png" class title="This is an image"><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/18.png" class title="This is an image"><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/19.png" class title="This is an image">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Java代理模式的基本介绍&quot;&gt;&lt;a href=&quot;#1-Java代理模式的基本介绍&quot; class=&quot;headerlink&quot; title=&quot;1.Java代理模式的基本介绍&quot;&gt;&lt;/a&gt;1.Java代理模式的基本介绍&lt;/h2&gt;&lt;p&gt;  首先得跟大家说明白，本篇文章的设
      
    
    </summary>
    
    
      <category term="-设计模式" scheme="https://waibizi.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="-Java -设计模式" scheme="https://waibizi.github.io/tags/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>再谈自动装箱(AutoBoxing)，自动拆箱(Unboxing)</title>
    <link href="https://waibizi.github.io/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/"/>
    <id>https://waibizi.github.io/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/</id>
    <published>2020-06-09T14:49:29.000Z</published>
    <updated>2020-07-13T05:43:37.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h2><p>  自动装箱就是自动将基本数据类型转换为<strong>包装器类型</strong>；自动拆箱就是自动将包装器类型转换为<strong>基本数据类型</strong>。<br></p><p>  ps：Integer自动转换为<strong><font color=" #FF8C00">int</font></strong>类型，这个就是自动拆箱的过程，int自动转换为Integer就是装箱的过程。<br></p><div align="center"><img src="/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/1.png" class title="This is an image"></div><br><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h2><center>概念不难理解，不如尝试反编译一下，看下底层是什么什么吧。</center><br><center>废话少说，直接动手肝</center><div align="center"><img src="/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/2.png" class title="This is an image"></div><p>  通过<strong><font color=" #FF8C00">反编译字节码</font></strong>可以很明显地看到一些效果，将<strong><font color=" #FF8C00">装箱与拆箱</font></strong>的过程反映了出来。<br></p><h2 id="3-自动装箱与拆箱的一些验证"><a href="#3-自动装箱与拆箱的一些验证" class="headerlink" title="3.自动装箱与拆箱的一些验证"></a>3.自动装箱与拆箱的一些验证</h2><div align="center"><img src="/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/3.png" class title="This is an image"></div><br><center>打印结果是**<font color=" #FF8C00">true</font>**，此步进行了自动拆箱操作</center><br><center><font color="#00FA9A">拆箱</font>的验证，可以通过<font color="#00FA9A">字节码<br></font>看到</center><br><div align="center"><img src="/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/4.png" class title="This is an image"></div><br><center>再来一次，这次使用<font color="#00FA9A">equals</font>,可以看到是装箱了</center><br><div align="center"><img src="/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/5.png" class title="This is an image"></div><br><p>具体原因是因为jdk内部使用equals的时候，传入是Object，int类型赋值到Object的时候是装箱的过程<br></p><div align="center"><img src="/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/6.png" class title="This is an image"></div><br><br><center>小结</center><p>1.自动装箱与自动装箱虽然在使用当中可以省略很多不用考虑的因素，但是这是因为Java自己做了这部分的工作（只是你看不到）;    <br></p><p>2.大量使用自动装箱会<font color="#FF33FF">影响一部分的性能</font>（因为要生成Object类型）;<br></p><p>3.采用‘==’与‘equals’的时候，自动装箱与自动拆箱的原因为啥不同;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-基础概念&quot;&gt;&lt;a href=&quot;#1-基础概念&quot; class=&quot;headerlink&quot; title=&quot;1.基础概念&quot;&gt;&lt;/a&gt;1.基础概念&lt;/h2&gt;&lt;p&gt;  自动装箱就是自动将基本数据类型转换为&lt;strong&gt;包装器类型&lt;/strong&gt;；自动拆箱就是自动将包装
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【CAS基础】CAS简单入门</title>
    <link href="https://waibizi.github.io/2020/06/09/%E3%80%90CAS%E5%9F%BA%E7%A1%80%E3%80%91CAS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"/>
    <id>https://waibizi.github.io/2020/06/09/%E3%80%90CAS%E5%9F%BA%E7%A1%80%E3%80%91CAS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</id>
    <published>2020-06-09T13:42:43.000Z</published>
    <updated>2020-06-09T14:47:29.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-CAS概念"><a href="#1-CAS概念" class="headerlink" title="1.CAS概念"></a>1.CAS概念</h2><p>  首先，跟大家强调一下，CAS是一种思想！！一种思想！！一种思想！！！（重要的话说三次）</p><p>  CAS的的英文全称<strong><font color=" #FF8C00">Compare-and-Swap</font></strong>，中文名称叫做比较并交换，一种才不采用强制性锁机制下的一种值更新策略；在并发的情况下，挺多情况是直接synchronized跟voliate或者其他锁机制实现并发时保证数据一致性的;</p><h2 id="2-CAS的一个小Demo"><a href="#2-CAS的一个小Demo" class="headerlink" title="2.CAS的一个小Demo"></a>2.CAS的一个小Demo</h2><p>  CAS呢，底层是在unsafe类当中的，但是JDK当中有许多类都会采用CAS去保障数据的并发问题，我们简单看一个并发包当中的类，然后去认识CAS吧;</p><img src="/2020/06/09/%E3%80%90CAS%E5%9F%BA%E7%A1%80%E3%80%91CAS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/1.png" class title="This is an image"><center>这是一个安全的int，我初始化这个int为5，然后采用了</center><center>AtomicInteger的CAS实现</center><center>大概就是expect期望值是5的话，把值改为update的值</center><center>然后我们就简单进去源码看下吧····</center><img src="/2020/06/09/%E3%80%90CAS%E5%9F%BA%E7%A1%80%E3%80%91CAS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/2.png" class title="This is an image"><p>参数的意思:</p><p><font color=" #FF8C00">this</font>：当前对象</p><p><font color=" #FF8C00">valueOffset</font>：内存地址</p><p><font color=" #FF8C00">expect</font>：期待值</p><p><font color=" #FF8C00">update</font>：更新值</p><p>再往下看就不是我们此时关注的重点啦，因为再往下就是unsafe类</p><p>这个类我会的后续再写一篇介绍</p><p>（真的是太多了）</p><h2 id="3-CAS的缺点以及ABA问题"><a href="#3-CAS的缺点以及ABA问题" class="headerlink" title="3.CAS的缺点以及ABA问题"></a>3.CAS的缺点以及ABA问题</h2><p>  <font color="#7B68EE" size="5">无锁机制固然好，但是有一些比较明显的缺点也随着带来了，我们先来简单说一下CAS当中自旋出现的问题;</font></p><p>假设我现在有两个线程：线程A与线程B，然后有一个变量，表示的是卡上的余额;</p><p>线程A，此时知道的初始值是50元，线程B也是晓得此时初始值是50元：</p><p>线程A想把50更新为100，线程B想把50更新为零，那么此时线程A与线程B的“期望值”都是50，线程A的运气比较好，先抢占到时间片，开始更新数据，并且更新数据成功。而线程B因为一些中间处理操作，需要时间等待，此时拿着期望值“50”，进行CAS比较交换的时候，发现期望值无效，于是重新获取了一次最新的“真实值”，然后很不凑巧，线程A此时又想修改值，而且时间片也被线程A抢占了，线程A此时拿着最新的期望值是“100”，又更新成功了，把值重新改回50，而线程B这倒霉蛋又拿着期望值为“100”的，想过来修改值，又没办法修改···</p><p>如果线程B一直运气不好，抢不到时间片，就会导致线程B一直处于自旋的状态···</p><p>【ABA问题】</p><p>ABA问题比较好理解</p><p>  1.线程A，期望值是50，欲更新值为100</p><p>  2.线程B，期望值是50，欲更新值为100</p><p>  线程A首先拿到时间片，进行值的更新，此时线程B因为某些问题（阻塞了一段时间），没有抢占到时间片。此时A更新了值了，然后突然来了一个线程C，比线程B先抢占到了时间片（线程B挺可怜的），此时线程C的期望值是100，欲修改值是50，CAS执行成功了，此时线程B终于阻塞完了，拿着期望值为50，更新值为100的操作姗姗来迟，此时CAS也成功了。可是线程B并不知道他自己修改了的值是经过了50-&gt;100-&gt;50-&gt;100。除开掉前面的50是初始值，100,50,100三个数就是ABA的代表，可以将100替换为A理解，50替换为B理解。</p><p>这个ABA会导致什么问题的出现呢？</p><p>如果说此时我的银行卡收入了50元，卡内原先余额为50元，此时就要更新为100元，由于一些比较特殊的原因（难不成是工程师的锅），此时50欲更新为100有两条线程，就跟上面例子一样;然后此时突然我的女朋友想要花我的银行卡的钱，我的银行卡也需要扣费了，三个线程出现了上面那种执行顺序问题，我的卡此时不就白白赚了50块钱了吗？（可能例子不大恰当，但是ABA当中就是这种问题的发生）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-CAS概念&quot;&gt;&lt;a href=&quot;#1-CAS概念&quot; class=&quot;headerlink&quot; title=&quot;1.CAS概念&quot;&gt;&lt;/a&gt;1.CAS概念&lt;/h2&gt;&lt;p&gt;  首先，跟大家强调一下，CAS是一种思想！！一种思想！！一种思想！！！（重要的话说三次）&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="-Java基础" scheme="https://waibizi.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="CAS" scheme="https://waibizi.github.io/tags/CAS/"/>
    
      <category term="Java" scheme="https://waibizi.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
