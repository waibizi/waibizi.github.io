<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>歪鼻子</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://waibizi.github.io/"/>
  <updated>2020-07-12T09:54:41.660Z</updated>
  <id>https://waibizi.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Java的IO模型】BIO、NIO基础入门</title>
    <link href="https://waibizi.github.io/2020/07/12/%E3%80%90Java%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E3%80%91BIO%E3%80%81NIO%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>https://waibizi.github.io/2020/07/12/%E3%80%90Java%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E3%80%91BIO%E3%80%81NIO%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</id>
    <published>2020-07-12T07:52:38.000Z</published>
    <updated>2020-07-12T09:54:41.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、IO模型"><a href="#一、IO模型" class="headerlink" title="一、IO模型"></a>一、IO模型</h2><center>作为一个Java开发者，对于IO模型是绕不开的一环：所谓的IO模型，就是你采用什么的通道模型进行数据的接收与发送</center><center>Java的网络编程的IO模型主要有：BIO、NIO</center><center>本篇主要是学一下BIO与NIO的基础</center><h2 id="二、什么是BIO"><a href="#二、什么是BIO" class="headerlink" title="二、什么是BIO"></a>二、什么是BIO</h2><center> Java BIO英文名称是<font color="#FF33FF">Java Blocking IO</font>,顾名思义就是Java的阻塞IO模型;</center>BIO的主要特性就是同步并阻塞（传统阻塞型IO），服务器在接收到一个连接的时就会给这个连接分配线程，也就是每一个连接都需要启动一个线程进行处理;如果这个连接此时没有任何操纵的情况，只要还在连接当中的话，就会一直占用着这个线程;这里我们可以想一下，如果QQ采用的是BIO的话，那还得了嘛（嘿嘿）;<center>可是我们还是得来学一下BIO，唔····</center><center>简单看一下BIO的模型图吧</center><img src="/2020/07/12/%E3%80%90Java%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E3%80%91BIO%E3%80%81NIO%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1.jpg" class title="This is an image"><pre><code>在这个模型图当中，我们采用了四个连接，然后服务器就会去创建四个线程与客户端进行连接;</code></pre><center>那么Java的BIO在哪咧···其实就是大家Java基础经常用的</center><center>Java.io包下</center><pre><code>其实以前学网络编程的时候，这个我经常用不过我当时没有管这个叫BIO（今天废话有点多）;</code></pre><center>其实以前学网络编程的时候，这个我经常用不过我当时没有管这个叫BIO（今天废话有点多）</center><center>我们简单来看一下简单实例吧</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.waibizi;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 吴典秋</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/6 13:42</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: BIO的服务端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//采用线程池机制</span></span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor =</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor</span><br><span class="line">                        (<span class="number">8</span>,<span class="number">16</span>,<span class="number">10</span>,</span><br><span class="line">                                TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                Executors.defaultThreadFactory());</span><br><span class="line">        <span class="comment">//创建一个端口为1024的ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">1024</span>);</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"使服务器的线程名称为:"</span>+Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//监听、等待客户端的连接</span></span><br><span class="line">            System.out.println(<span class="string">"等待连接当中"</span>);</span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">"有客户端连接进来了"</span>);</span><br><span class="line">            threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class="line">                handler(socket);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"通讯的线程名称为:"</span>+Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket获取输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"进行信息交流的线程名称为:"</span>+Thread.currentThread().getName());</span><br><span class="line">                System.out.println(<span class="string">"Reading········"</span>);</span><br><span class="line">                <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span> (read!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,read));</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭与客户端的连接"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center>运行一下吧</center><br><img src="/2020/07/12/%E3%80%90Java%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E3%80%91BIO%E3%80%81NIO%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/2.jpg" class title="This is an image"><center>我们采用telnet来连接一下就可以了</center><img src="/2020/07/12/%E3%80%90Java%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E3%80%91BIO%E3%80%81NIO%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/3.jpg" class title="This is an image"><br><br><center>我这里开了三个连接，可以看到创建了三个线程了</center><center>然后再简单发几条消息康康吧</center><img src="/2020/07/12/%E3%80%90Java%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E3%80%91BIO%E3%80%81NIO%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/4.jpg" class title="This is an image"><center>然后程序你自己跑一遍，挂着康康你就晓得了</center><center>这玩意一直在连接当中···</center><center>【分析】</center>    BIO的案例分析当中，主要是每连接每线程的IO通信模型，在BIO当中serverSocket.accept()、serverSocket.read()、serverSocket.write()这三个方法都是同步阻塞的;<center>那么BIO适用于什么场景呢</center>     BIO的这种网络IO模型适用于连接数目比较小且固定的架构，这种方式对于服务器的配置要求会比较高，这种连接方式比较容易理解，在JDK1.4以前，BIO的通信方式是唯一的选择;BIO的几个要点：<p>1.每个请求都需要创建<font color="#FF33FF">独立的线程</font>，与对应的客户端进行交互;</p><p>2.当并发数比较大的时候，需要创建<font color="#FF33FF">大量的线程</font>来处理连接，</p><p>  系统资源占用比较大（别看我已经采用了线程池机制，但是一直阻塞当中的话线程池其实作用不大的）;</p><h2 id="三、什么是NIO"><a href="#三、什么是NIO" class="headerlink" title="三、什么是NIO"></a>三、什么是NIO</h2><p> Java NIO全称 <font color=" #FF8C00">Java non-blocking IO(</font>也有人称之为New IO),是Java提供的一个全新的IO模型;NIO主要是非阻塞的同步IO，BIO是阻塞的;</p><center>NIO当中主要有三大核心功能：Channel（通道）、Buffer（缓冲区）、Selector（选择器）;</center><br><br><center>【分享一个我听到十分好的比喻】</center><br><br><center>Selector是中央控制器，Buffer是承载数据的容器，而Channel可以说最基础的门面，它是本地I/O设备，网络I/O的通信桥梁，只有搭建了这座桥梁，数据才能被写入Buffer，连接才能被Selector控制;</center><br><br><center>NIO是一种非阻塞型的IO模型，也就是NIO的线程模型当中对Socket发起的连接不需要每个都创建一个线程，完全可以使用一个Selector来多路复用监听N多个Channel是否有请求，该请求是对应的连接请求，还是发送数据的请求;</center><br><br><center>这里面是基于操作系统底层的Select通知机制的，一个Selector不断的轮询多个Channel，这样避免了创建多个线程</center><br><br><center>具体模型图如下</center><br><br><img src="/2020/07/12/%E3%80%90Java%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E3%80%91BIO%E3%80%81NIO%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/5.jpg" class title="This is an image"><p>1）每一个Channel都会对应一个Buffer；</p><p>2）Select对应一个线程，一个线程对应多个Channel；</p><p>3）程序切换到哪个Channel是由事件决定的；</p><p>4）Buffer就是一个内存块，底层是有一个数组；</p><p>5）NIO当中的Buffer是可以读又可以写的，只需要flip就可以切换;</p><center>说了那么多</center><center>关于Selector、Buffer、Channel这三个概念是比较模糊的</center><center>下面具体说说这三个</center><center>【关于Selector、Buffer、Channel具体介绍】</center>**Selector**<pre><code>Selector就是一个选择器，可以选择一个通道进行通信，这样就可以不使用那么多线程去通信，具体如下：</code></pre><p>1）Java的NIO，是一种非阻塞的IO交互方式。可以用于一个线程处理多个客户端连接，采用的就是选择器的机制;</p><p>2）选择器可以监听多个已经注册的通道是否有时间发生，如果有事件发生，便获取事件然后针对每个事件进行想用的处理。这样就可以只用一个单线程去管理多个通道，也就是处理多个连接和请求;</p><p>3）采用了<font color=" #FF8C00">Selector机制</font>可以在真正有读写实践的时候，才会进行读写，就大大减少了系统的开销，不必为每个连接都创建线程，不用去维护多个线程，避免了多个线程上下文切换所带来的损耗;</p><p><strong>Channel</strong></p><pre><code>Channel的意思就是通道，有点类似与流，但是有些区的不同;</code></pre><p>1）通道可以同时进行读写操作，而流要么只能读或者只能写（可以参考FileInputStream与FileOutputStream）;</p><p>2）通道可以实现异步读写数据；</p><p>3）通道可以从<font color=" #FF8C00">缓冲区</font>读数据，也可以写入数据到缓冲当中；</p><p><strong>Buffer</strong></p><pre><code>Buffer的意思就是缓冲区，缓冲区是一个读写数据的内存块，缓冲区对象内置了一些机制，可以追踪和记录缓冲区的状态变化情况;</code></pre><p>1）Java当中提供了丰富的Buffer子类（Byte,Float,int等等）;</p><center>谈了那么多，上上代码吧，代码的注释挺多的</center><center>Server端</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.waibizi.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 歪鼻子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/12 18:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建ServerSocketChannel</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//得到一个Selector</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//绑定一个端口666，在服务器端监听</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line">        <span class="comment">//设置为非阻塞,NIO就是在这个部分可以设置为非阻塞的状态</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//把serverSocketChannel注册到selector关联，并将Channel设置为OP_ACCEPT，OP_ACCEPT表示的就是就绪状态</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">"注册后的selectionKey的数量 = "</span>+selector.keys().size());</span><br><span class="line">        <span class="comment">//循环等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//这里我们等待1秒，如果没有时间发生，则返回</span></span><br><span class="line">            <span class="keyword">if</span> (selector.select(<span class="number">1000</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"服务器等待了一秒，没有人连接"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果返回的大于0，就获取到相关的selectionKey</span></span><br><span class="line">            <span class="comment">//1. 如果返回的&gt;0， 表示已经获取到关注的事件</span></span><br><span class="line">            <span class="comment">//2. selector.selectedKeys() 返回关注事件的集合</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            System.out.println(<span class="string">"SelectionKey的数量 = "</span>+selectionKeys.size());</span><br><span class="line">            <span class="comment">//遍历Set&lt;SelectionKey&gt;，使用迭代器遍历</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext())&#123;</span><br><span class="line">                <span class="comment">//获取到SelectionKey</span></span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line">                <span class="comment">//根据key对应的通道发生的事件做相应的处理:如果key的状态是OP_ACCEPT也就是有一个连接请求</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">//调用accept这个方法，表示可以进行TCP三次握手了</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    System.out.println(<span class="string">"客户端连接成功！生成了一个socketChannel，本地连接的socketChannel的标识码是 = "</span>+socketChannel.hashCode());</span><br><span class="line">                    <span class="comment">//将SocketChannel 设置为非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//将socketChannel注册到selector，关注事件为OP_READ,同时给socketChannel</span></span><br><span class="line">                    <span class="comment">//关联到一个Buffer</span></span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                    System.out.println(<span class="string">"客户端连接了，selectionKey的数量 = "</span>+selector.keys().size());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果key的状态是OP_READ，也就是有数据发送过来了，此时需要读取客户端发送的数据了</span></span><br><span class="line">                <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">//通过key反向获取到对应的Channel</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//获取到该channel关联的buffer</span></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">int</span> read = channel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (read &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">byte</span>[] data = buffer.array();</span><br><span class="line">                        String msg = <span class="keyword">new</span> String(data).trim();</span><br><span class="line">                        System.out.println(msg);</span><br><span class="line">                        System.out.println(StandardCharsets.UTF_8.decode(buffer).toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//System.out.println("来自客户端发送的数据是："+new String(buffer.array()));</span></span><br><span class="line">                    <span class="comment">//System.out.println("UTF8转码之后"+ StandardCharsets.UTF_8.decode(buffer).toString());</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//手动从集合中移动当前的selectionKey，防止重复操作</span></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center>Client端</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.waibizi.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 歪鼻子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/18 20:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//得到一个网络通道</span></span><br><span class="line">        SocketChannel channel = SocketChannel.open();</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//提供服务器端的ip和端口</span></span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="keyword">if</span> (!channel.connect(inetSocketAddress))&#123;</span><br><span class="line">            <span class="keyword">while</span> (!channel.finishConnect())&#123;</span><br><span class="line">                System.out.println(<span class="string">"客户端可以边连接边进行其他的操作"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果连接成功，就开始发送数据</span></span><br><span class="line">        String msg = <span class="string">"歪鼻子已就位!"</span>;</span><br><span class="line">        <span class="comment">//将发送数据以字节的形式写入到buffer当中</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">        <span class="comment">//将buffer写入到channel当中</span></span><br><span class="line">        channel.write(buffer);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.waibizi.group;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 歪鼻子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/7/9 16:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientA</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 服务的IP地址 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="comment">/* 服务的端口 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">2048</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientA</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/* 打开选择器 */</span></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">/* 连接服务器 */</span></span><br><span class="line">        socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(HOST,PORT));</span><br><span class="line">        <span class="comment">/* 设置为非阻塞状态 */</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">/* 将通道注册到选择器上 */</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        name = <span class="string">"ClientA"</span>;</span><br><span class="line">        System.out.println(name+<span class="string">" is ok····"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String info)</span></span>&#123;</span><br><span class="line">        info = name + <span class="string">"说："</span>+info;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (selector.select()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">/* 得到相关的通道 */</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">/* 得到一个buffer */</span></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="comment">/* 读取 */</span></span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(buffer.array()).trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/* 启动客户端 */</span></span><br><span class="line">        ClientA client = <span class="keyword">new</span> ClientA();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    client.read();</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">3000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">/* 向客户端发送数据 */</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">            String msg = scanner.nextLine();</span><br><span class="line">            client.send(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center>Server端打印情况</center>{% asset_img 6.jpg This is an image %}<center>简单小案例（群聊系统）</center><br><center>截图效果先</center><br><center>服务端</center><br>{% asset_img 7.jpg This is an image %}<center>客户端A</center>{% asset_img 8.jpg This is an image %}<center>客户端B</center>{% asset_img 9.jpg This is an image %}<center>服务端代码（注释同样很丰富，为了方便有截图行号）</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.waibizi.group;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 歪鼻子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/7/9 14:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 群聊天，服务端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 定义属性 */</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化服务端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/* 打开选择器 */</span></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">/* 打开通道 */</span></span><br><span class="line">        listenChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">/* 绑定端口 */</span></span><br><span class="line">        listenChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">        <span class="comment">/* 设置为非阻塞状态 */</span></span><br><span class="line">        listenChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">/* 将通道注册到选择器当中（注意：注册的状态应该是接受的状态） */</span></span><br><span class="line">        listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">/* 如果选择器有事件需要处理，也就是选择器的选择大于0 */</span></span><br><span class="line">            <span class="keyword">if</span> (selector.select()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">/* 遍历得到所有的selectedKey（每个Channel向Selector注册时,都将会创建一个selectionKey） */</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                    <span class="comment">/* 取出selectionKey */</span></span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="comment">/* 监听到key的状态为accept */</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        SocketChannel sc = listenChannel.accept();</span><br><span class="line">                        <span class="comment">/* 将通道收到的socketChannel设置为非阻塞状态 */</span></span><br><span class="line">                        sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                        <span class="comment">/* 将该socketChannel注册到selector并设置为状态read */</span></span><br><span class="line">                        sc.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                        System.out.println(<span class="string">"地址是"</span>+sc.getRemoteAddress().toString().substring(<span class="number">1</span>)+<span class="string">"的用户上线了"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* 如果通道是read事件，即通道是可读状态 */</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                        read(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* 移除已经处理过的selectionKey */</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key读取消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/* 得到Key当中的channel */</span></span><br><span class="line">        channel = (SocketChannel) key.channel();</span><br><span class="line">        <span class="comment">/* 创建缓冲区 */</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">/* 如果读取到数据 */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel.read(buffer)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">/* 把缓冲区的数据转成字符串 */</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                System.out.println(<span class="string">"来自客户端的消息："</span>+msg.trim());</span><br><span class="line">                <span class="comment">/* 向除了自己的其他客户端转发消息 */</span></span><br><span class="line">                sendInformationToOther(msg,channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">" 离线了.."</span>);</span><br><span class="line">                <span class="comment">/* 取消注册 */</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">/* 关闭通道 */</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException ee)&#123;</span><br><span class="line">                ee.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInformationToOther</span><span class="params">(String msg,SocketChannel self)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器转发消息中······"</span>);</span><br><span class="line">        <span class="comment">/* 遍历所有注册到选择器的Socket并且排除自己 */</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey key:selector.keys())&#123;</span><br><span class="line">            <span class="comment">/* 通过key取出channel */</span></span><br><span class="line">            Channel target = key.channel();</span><br><span class="line">            <span class="keyword">if</span> (target <span class="keyword">instanceof</span> SocketChannel &amp;&amp; target != self)&#123;</span><br><span class="line">                SocketChannel dest = (SocketChannel)target;</span><br><span class="line">                <span class="comment">/* 将msg存储到buffer */</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">/* 将buffer的数据写入到通道当中 */</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server();</span><br><span class="line">        server.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center>Client（由于客户端A与B的代码几乎是一致的，所以就只放一个）</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.waibizi.group;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 歪鼻子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/7/9 16:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientA</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 服务的IP地址 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="comment">/* 服务的端口 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">2048</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientA</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/* 打开选择器 */</span></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">/* 连接服务器 */</span></span><br><span class="line">        socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(HOST,PORT));</span><br><span class="line">        <span class="comment">/* 设置为非阻塞状态 */</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">/* 将通道注册到选择器上 */</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        name = <span class="string">"ClientA"</span>;</span><br><span class="line">        System.out.println(name+<span class="string">" is ok····"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String info)</span></span>&#123;</span><br><span class="line">        info = name + <span class="string">"说："</span>+info;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (selector.select()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">/* 得到相关的通道 */</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">/* 得到一个buffer */</span></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="comment">/* 读取 */</span></span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(buffer.array()).trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/* 启动客户端 */</span></span><br><span class="line">        ClientA client = <span class="keyword">new</span> ClientA();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    client.read();</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">3000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">/* 向客户端发送数据 */</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">            String msg = scanner.nextLine();</span><br><span class="line">            client.send(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、从传统拷贝到零拷贝"><a href="#四、从传统拷贝到零拷贝" class="headerlink" title="四、从传统拷贝到零拷贝"></a>四、从传统拷贝到零拷贝</h2><center>我们先来看看传统的文件IO</center><br>{% asset_img 10.jpg This is an image %}<p>（1）read() syscall ：java客户端（jvm虚拟机）向操作系统</p><pre><code>发起读磁盘数据的请求;</code></pre><p>（2）ask for data ：系统向磁盘读数据;</p><p>（3）data to kernel buffer through DMA： 磁盘数据通过</p><pre><code>DMA读到内核缓存区</code></pre><p>（4）data to kernel buffer through DMA： 磁盘数据通过</p><pre><code>DMA读到内核缓存区</code></pre><p>（5）code logic coutinues：业务逻辑处理</p><p>（6）wirte() syscall,copies data to kernel socket </p><pre><code>buffer：客户端向系统发起写请求，并且把用户缓冲区数据复制到内核缓冲区&lt;br/&gt;</code></pre><p>从<font color=" #FF8C00">用户态与内核态</font>角度分析</p><p>read() syscall：从用户态切换为内核态</p><p>copy data to user buffer：从内核态切换为用户态</p><p>wirte() syscall,copies data to kernel socket buffer：从用户态切换为内核态</p><p>write() returns：从内核态切换为用户态</p><p>从整体得到角度看，一次IO操作进行了四次用户空间与内核空间的上下文切换，以及四次的数据拷贝（用户拷贝到内核，内核拷贝到用户）;我们在传统的IO当中可以看到，从内核拷贝到用户是没必要的，就是在消耗性能，于是提出了零拷贝机制</p><center>（传统的InputStream与OutputStream就是传统IO）</center><center>Linux2.4之前零拷贝机制</center><img src="/2020/07/12/%E3%80%90Java%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E3%80%91BIO%E3%80%81NIO%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/11.jpg" class title="This is an image"><p>2.4之前的零拷贝用户与内核上下文切换有两次</p><p>（1）sendfile() syscall：从用户态切换为内核态</p><p>（2）sendfile() returns：从内核态切换为用户态</p><p>2.4之前的零拷贝数据拷贝有三次</p><p>data to kernel buffer through DMA：磁盘数据通过DMA读到内核缓存区</p><p>wirte data to target socket buffer：从内核空间缓冲区写到socket缓冲区</p><p>从内核空间缓冲区写到socket缓冲区：socket向目标发送数据</p><p>（Linux2.4之前的零拷贝是把 kernel buffer 中全部的数据 拷贝到socket buffer）</p><p>在Linux2.4之后对于零拷贝进行了优化，对于之前的kernel buffer拷贝全部数据优化成了拷贝地址和数据长度（这部分的数据量小到可以忽略不计），当需要真正使用数据的时候，客户端会从socket buffer当中拿到地址与长度，然后到达kernel buffer当中去索取数据进行操作;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、IO模型&quot;&gt;&lt;a href=&quot;#一、IO模型&quot; class=&quot;headerlink&quot; title=&quot;一、IO模型&quot;&gt;&lt;/a&gt;一、IO模型&lt;/h2&gt;&lt;center&gt;作为一个Java开发者，对于IO模型是绕不开的一环：所谓的IO模型，就是你采用什么的通道模型进行数
      
    
    </summary>
    
    
      <category term="-BIO、NIO" scheme="https://waibizi.github.io/categories/BIO%E3%80%81NIO/"/>
    
    
      <category term="-IO模型" scheme="https://waibizi.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>synchronized锁升级分析</title>
    <link href="https://waibizi.github.io/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/"/>
    <id>https://waibizi.github.io/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/</id>
    <published>2020-06-24T09:17:30.000Z</published>
    <updated>2020-07-04T14:14:07.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Mutex介绍"><a href="#1-Mutex介绍" class="headerlink" title="1.Mutex介绍"></a>1.Mutex介绍</h2><p>  <font color=" #FF8C00">Mutex</font>中文名称是<font color="#00FA9A">互斥锁</font>，跟着中文名称很好理解了，就是为了互斥;<br></p><p>  在并发的情况下，对于一个对象的操作，可能会导致数据不一致性问题，为了保证共享数据操作的完整性。每个对象都对应于一个可称为” 互斥锁” 的标记，这个标记用来保证在任一时刻，只能有<font color="#00FA9A">一个线程</font>访问该对象；<br></p><h2 id="2-经典问题引入"><a href="#2-经典问题引入" class="headerlink" title="2.经典问题引入"></a>2.经典问题引入</h2><p>  前言：synchronized是获取锁对象！！！是一个操作，将锁对象加到代码上面;（这句话多记几遍，不然下面会踩坑） <br></p><p>  下面这段代码，创建了1000条线程去执行一个static的变量，每一条线程使的count加一，为了使问题更加明显，这里让线程在count++之前，睡眠了一毫秒。在打印输出结果之前，再让主线程睡眠三秒，保证所有线程都执行完再打印数据;原本预期结果是1000，按照正常逻辑也应该是1000.其实不然，每个电脑的结果不同，你自己试着跑一遍吧。<br></p><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/1.jpg" class title="This is an image"></center><br><p>  打印出来肯定不是1000，根据<font color=" #FF8C00">JMM的模型</font>，可以推断是工作内存的变量没有同步到主内存当中。<br></p><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/2.jpg" class title="This is an image"></center><br><center>采用synchronized给当前对象加锁，打印结果是1000</center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/3.jpg" class title="This is an image"></center><br><p>通过字节码分析，可以看到同步的部分是使用<font color="#00FA9A">monitorenter和monitorexit指令</font>。这两个指令隐式地执行了mutex的lock和unlock操作，用于提供原子性的操作;</p><p>  这两个指令的命名也有有原因的，原则上他们是获取了这个对象的<font color=" #FF8C00">监视器（monitor）</font>,这个过程是排他的，也就是说同一时刻只有一个对象能获取到由synthronized保护的对象;<br></p><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/4.jpg" class title="This is an image"></center><br><p>好了，我们加上<font color=" #FF8C00">synchronized</font>修饰，运行结果是1000毫无疑问的<br></p><h2 id="3-深入了解synchronized"><a href="#3-深入了解synchronized" class="headerlink" title="3.深入了解synchronized"></a>3.深入了解synchronized</h2><p>  首先明确一下我们只需要关注<font color="#00FA9A">对象头</font>的此处位置三个数字，这个地方是对象的锁状态（下面这张图只是举例说明看哪）；<br></p><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/5.jpg" class title="This is an image"></center><br><center>然后我们只需关于这些状态</center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/6.jpg" class title="This is an image"></center><br><center>先来看下锁升级的流程图</center>  <br><p>  在Java SE1.6的时候对于synchronized进行了优化，也就是synchronized在加锁的时候，里面关于锁的机制进行升级，升级的过程如下流程图：<br></p><center>（以下都是加了synchronized的时候进行分析的结果）</center><br><center>当线程第一次访问这个对象时</center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/7.jpg" class title="This is an image"></center><br><p>解释：线程一访问到synchronized代码块的时候，先检查对象的标记位，第一次进来的线程肯定不会读到标记检查，就将对象占有，进行标记，然后执行代码块，执行完成之后不会清除对象的标记。（这个过程是偏向锁的过程）<br></p><center>当有第二个线程接着访问此对象的时候</center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/8.jpg" class title="This is an image"></center><br><p>解释：当第二个线程访问到synchronized代码块的时候，检查到有标记（因为上一个对象不会清除），判断上一个对象是否存活，如果不存活了，则跟第一个线程进来一样的步骤，如果存活，则进入到<font color=" #FF8C00">轻量级锁</font>，也就是<font color="#00FA9A">锁自旋</font>；如果自旋太久了了，也就是大于十次了，就转移到<font color="#00FA9A">重量级锁</font>，将线程挂起；<br></p><h2 id="4-synchronized锁验证"><a href="#4-synchronized锁验证" class="headerlink" title="4.synchronized锁验证"></a>4.synchronized锁验证</h2><center>无锁状态</center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/9.jpg" class title="This is an image"></center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/10.jpg" class title="This is an image"></center><br><center>偏向锁</center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/11.jpg" class title="This is an image"></center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/12.jpg" class title="This is an image"></center><br><center>解释：因为JVM底层进行加载的时候，会将延时加载的对象加上偏向锁;</center><br><center>注意：此时的偏向锁是一种特殊的偏向锁，具体往下看</center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/13.jpg" class title="This is an image"></center><br><p>在对象头的位置上，我们可以看到线程ID此时其实是全为零的，再结合偏向锁的概念，偏向锁，偏向、偏向…其实就是偏向了某个线程，此时不偏向其他线程，也可以理解这个就是一个特殊的“无锁”；<br></p> <center>那么怎么让他<font color="#00FA9A">偏向</font>呢？</center> <center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/14.jpg" class title="This is an image"></center><center>上图的代码可以让这把锁进行偏向</center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/15.jpg" class title="This is an image"></center><br><center>可以看到依然是偏向锁的情况下，有了偏向的线程ID了</center><br><center>注意：你要讲访问的对象加synchronized修饰才有这种效果</center><br><center>自旋锁(轻量级锁)</center><br><p>  自旋锁是自我上锁了，这个自我上锁的条件，是上一个线程还存活，那么就想办法让线程存活的情况下，再执行一条线程；<br></p><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/16.jpg" class title="This is an image"></center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/17.jpg" class title="This is an image"></center><br><p>在主线程不在睡眠直接加载类的情况下，JVM不底层没有触碰到stu的synchronized代码片段，但是在创建第二个线程创建的时候，JVM底层触碰到了stu的synchronized代码片段，导致了中间会变化了偏向锁，然后根据流程图，第二个线程访问这个具有偏向锁，且第一个线程为消亡的情况下（在main线程当中创建了另外一个线程，main线程肯定还不会消亡），会将偏向锁改为轻量级锁（自旋锁）。<br></p><p>ps:JVM中间转换过程目前能力原因找不到方法去证明，这是一个推断的想法。如果你有方法证明，可以联系一下我吗？<br></p><center>重量级锁</center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/18.jpg" class title="This is an image"></center><br><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/19.jpg" class title="This is an image"></center><br><p>  自旋状态还没结束，就会导致不断去自旋，自旋次数超过十了，就会将锁机制转换到重量级锁，这个过程可能比较麻烦去验证，这里主要是证明锁的存在，以及验证什么情况会产生不同的锁。<br></p><center>【小结】</center><br><p>  synchronized在这此笔记当中只是简单了验证了锁升级，以及synthronized的简单了解。关于synthronized还有很多很多需要学习的，锁的加锁过程怎么去debug，发现升级过程这些的，还需要好好加强<br></p><center>【题外话】</center><br><p>因为有点好奇延迟加载究竟延迟加载多久才加锁，在我自己电脑进行了测试，在写文章的时候是睡眠了这个值，也就是在我自己电脑上，睡眠了这么长的时间情况下，多运行几次会产生在无锁与偏向锁的切换，有兴趣的小伙伴可以自行尝试，然后在下方留言（这个对我有帮助哦，谢谢你啦）<br></p><center><img src="/2020/06/24/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%86%E6%9E%90/20.jpg" class title="This is an image"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Mutex介绍&quot;&gt;&lt;a href=&quot;#1-Mutex介绍&quot; class=&quot;headerlink&quot; title=&quot;1.Mutex介绍&quot;&gt;&lt;/a&gt;1.Mutex介绍&lt;/h2&gt;&lt;p&gt;  &lt;font color=&quot; #FF8C00&quot;&gt;Mutex&lt;/font&gt;中文名称是
      
    
    </summary>
    
    
      <category term="-Java锁" scheme="https://waibizi.github.io/categories/Java%E9%94%81/"/>
    
    
  </entry>
  
  <entry>
    <title>【并发基础】Java当中的几个锁概念</title>
    <link href="https://waibizi.github.io/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/"/>
    <id>https://waibizi.github.io/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/</id>
    <published>2020-06-14T16:55:30.000Z</published>
    <updated>2020-06-14T18:13:49.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>  Java对于并发场景，对于锁的使用是最重要的，这次主要是介绍一下Java当中的锁类别与场景：公平锁、非公平锁、乐观锁、悲观锁、偏向锁、轻量级锁、重量级锁、自旋锁、读写锁、锁粗化/锁消除、分段锁;</p><h2 id="2-公平锁与非公平锁"><a href="#2-公平锁与非公平锁" class="headerlink" title="2.公平锁与非公平锁"></a>2.公平锁与非公平锁</h2><p>  正如锁的名字所言，他们的要点就是在于公平或者非公平的这两个意思身上;</p><p>  假设我们有如下场景，Thread-1获得锁之后，其他线程如果需要获得锁，不管是公平还是非公平都是需要在外等待的;</p><center><font color=" #FF8C00">（注意，这里Thread-2到Thread-4是依次到达来等待锁的）</font></center><p>  那么接下来的场景就是体现公平锁跟非公平锁的时候了，Thread-1已经释放锁了，而剩下的几个线程都需要这个锁，那么应该怎么去分配锁呢？</p><p>  如果是公平锁，那么就是多来了一个线程，也得去队列当中待着，按照线程来竞争锁的顺序一个一个排队;</p><p>  如果是非公平锁的话，在Thread-2到Thread-4之间，他们去竞争这把锁的机会是同等的，也就是他们不用排队等待，谁竞争到了就先持有锁;</p><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/1.jpg" class title="This is an image"></center><p>实现例子：</p><p>注意：你需要了解<b><font color=" #FF8C00">ReentrantLock</font></b>的一些常识，例如这是一个可重入的锁，而且默认是非公平锁;</p><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/2.png" class title="This is an image"></center><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/3.png" class title="This is an image"></center><center>然后我们运行一下吧</center><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/4.png" class title="This is an image"></center><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/5.png" class title="This is an image"></center><center>我们开始start的时候，肯定是外部线程先进去等待了</center><center>然后再内部锁进去了等待，那么如果是公平锁</center><center>就是大家一起按顺序慢慢等</center><center>那么非公平肯定就没有顺序的啦</center><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/6.png" class title="This is an image"></center><center>这个位置改一下</center><center>然后再次运行就可以看到内部与外部的输出是交替的</center><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/7.png" class title="This is an image"></center><center>我这里就随便截图一个输出就行了</center><center>可以看到是交替的进行的</center><center>也就是不用按照线程去竞争锁的排队顺序的</center><center>大多数锁机制都是默认为非公平锁的</center><center>因为非公平锁有着比公平锁更好的性能</center><center>由于线程的上下文切换浪费性能</center><center>以及需要等待排队线程的唤醒操作等等都会影响浪费性能</center><h2 id="3-读写锁"><a href="#3-读写锁" class="headerlink" title="3.读写锁"></a>3.读写锁</h2><p>  大多数的人刚开始接触的锁其实都是属于排他锁，也就是线程独占锁，一旦线程占有这把锁的话，其他线程的任何操作想获取锁都是没办法获取的;</p><p>  然而在一些特定的场景下，我们并不希望一旦一个线程占有了这个锁，就无法进行其他的操作;</p><p>  <b><font color=" #00FA9A">读写锁</font></b>：也就是读写锁分离。读锁可以在没有写锁的时候，被多个线程共同占用，而写锁是独占的，也就是只能由一个线程去占用这把锁;</p><center>互斥的原则是</center><center>多个线程都是读的时候，都是可以共同持有锁</center><center>有一个写操作的时候，其他线程<font color=" #00FA9A">不能读也不能写</font></center><center>这里我们模拟一个队列，队列里面有写入操作与读取操作</center><center>在写入操作与读取操作的时候，我们分别加上写锁与读锁</center><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/8.png" class title="This is an image"></center><center>编写main方法测试</center><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/9.png" class title="This is an image"></center><center>我们从前面的理论知识推断，在读取的时候，</center><center>写操作是不能<font color=" #FF8C00">直接插入</font>的，因为是<b><font color=" #FF8C00">互斥的</font></b></center><center>也就是写操作的时候，必须在某一个时机</center><center>恰好！！读操作释放了锁，写操作接着占用了这把锁</center><center><font color=" #FF8C00">看下运行结果吧</font></center><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/10.png" class title="This is an image"></center><center>上面的demo只是为了验证锁</center><center>我们学习东西主要是为了使用</center><center>这个锁在缓存场景其实很适用的</center><p>回顾一下我们的缓存场景：不就是写的操作比较少，读的情况比较多，我们为了提高速度将缓存放置到内存当中嘛？</p><p>为了方便模拟的策略，我们先说一下我们要实现的一个小例子：我们模拟在缓存场景下，如果值存在，我们就直接get返回，并且这个get操作是多个线程可以共享的;如果值不存在的情况，多个线程只能有一个线程去获取到锁，并且触发查询数据库的操作;</p><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/11.png" class title="This is an image"></center><h2 id="4-自旋锁"><a href="#4-自旋锁" class="headerlink" title="4.自旋锁"></a>4.自旋锁</h2><p>  有的时候我们加上一些lock操作的时候，会导致上下文切换浪费性能，因为需要上锁再释放锁，有一些持有锁的时间比较短的情况下，我们可以采用<b><font color=" #00FA9A">自旋锁</font></b>;</p><p>  <b><font color=" #00FA9A">自旋锁</font></b>，顾名思义，自我“旋转”就变成了锁，这个自我旋转指的是去旋转CPU的时间片，不上锁的情况让线程在那里进行空转;</p><p>我们简单看一下需求，如果说主线程的那句打印，我们需要在所有的线程执行完毕之后再开始执行的话，不加lock的情况，我们应该怎么去操作;</p><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/12.png" class title="This is an image"><center>上面代码的执行时打印这样，还没有加自旋锁的情况的</center><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/13.png" class title="This is an image"></center><p>这里由于我的编码工具的缘故，所以我自旋的时候判断线程数目采用了2，不过这不是关键啦，主要是看下自旋的思想</p><center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/14.png" class title="This is an image"></center><h2 id="5-偏向锁"><a href="#5-偏向锁" class="headerlink" title="5.偏向锁"></a>5.偏向锁</h2><p>  <b><font color=" #FF8C00">偏向锁</font></b>，在synchronized锁升级时候，有去看到锁升级的采用了偏向锁，至于偏向锁怎么去实现，笔者暂时不清楚怎么去实现;</p><p>  <b><font color=" #00FA9A">偏向锁</font></b>主要用于大多数情况是一个线程去竞争这把锁的情况，也就是这个锁在大多数情况下，只有一个线程去多次获得。一旦有多个线程来<b><font color=" #00FA9A">竞争锁</font></b>了，偏向锁都会升级为其他锁的;</p><h2 id="6-其他几个锁的概念"><a href="#6-其他几个锁的概念" class="headerlink" title="6.其他几个锁的概念"></a>6.其他几个锁的概念</h2><p>  <b><font color=" #FF8C00">悲观锁</font></b>：例如synchronized加锁的情况，就是属于悲观锁，悲观锁，顾名思义，就是比较悲观，每一次我们都必须加锁;</p><p>  <b><font color=" #FF8C00">乐观锁</font></b>：就是比较少竞争的情况，我们没有进行加锁操作，如果竞争比较严重的时候，我们就对其进行加锁，这个取决于你怎么去实现;</p><p>  <b><font color=" #FF8C00">重量级锁</font></b>：synchronized就是一把重量级锁，但是synchronized没有那么低效率了，锁升级的过程让synchronized这把有着重量级锁的性能得到了提升;</p><p>  <b><font color=" #FF8C00">轻量级锁</font></b>：当偏向锁升级成轻量级锁的时候，我们称这种机制是轻量级锁;</p><p>  <b><font color=" #FF8C00">分段锁</font></b>：并发包下，例如常见的ConcurrentHashMap里面就采用了分段锁，主要是根据锁的位置不是大面积的情况，进行分段加锁;</p><p>  <b><font color=" #FF8C00">锁粗化</font></b>：如果说加锁位置是一大块的位置，没有更细粒度去加锁位置的话，就是锁粗化;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h2&gt;&lt;p&gt;  Java对于并发场景，对于锁的使用是最重要的，这次主要是介绍一下Java当中的锁类别与场景：公平锁、非公平锁、乐观锁、悲
      
    
    </summary>
    
    
      <category term="-Java并发" scheme="https://waibizi.github.io/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="-锁机制" scheme="https://waibizi.github.io/tags/%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>【线程通信】生产者消费者模型</title>
    <link href="https://waibizi.github.io/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <id>https://waibizi.github.io/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-06-11T17:44:11.820Z</published>
    <updated>2020-06-11T18:14:06.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-生产者消费者模型介绍"><a href="#1-生产者消费者模型介绍" class="headerlink" title="1.生产者消费者模型介绍"></a>1.生产者消费者模型介绍</h2><p>  <font color=" #FF8C00">生产者消费者模型，</font>是每一个学习多线程的的人都需要知道的模型;</p><p>大致情况就是：有两个线程，一个负责生产产品，一个消费产品，两者公用同一块内存区域，也就是产品放在了同一块内存上面，如果两个线程没有采用一定的措施或者采用的策略错误的情况下，容易出现一系列的问题，例如数据一致性问题，死锁问题;</p><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/1.png" class title="This is an image"><h2 id="2-为什么需要生产者消费者模型"><a href="#2-为什么需要生产者消费者模型" class="headerlink" title="2.为什么需要生产者消费者模型"></a>2.为什么需要生产者消费者模型</h2><p>  在多线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程;如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据;同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者;为了解决这个问题于是引入了生产者和消费者模式。</p><h2 id="3-生产者-消费者模型（线程阻塞，线程唤醒）"><a href="#3-生产者-消费者模型（线程阻塞，线程唤醒）" class="headerlink" title="3.生产者-消费者模型（线程阻塞，线程唤醒）"></a>3.生产者-消费者模型（线程阻塞，线程唤醒）</h2><p>  举例：线程1去奶茶，没有奶茶了，它就不执行了;线程二生产奶茶，通知线程1继续执行;</p><p>下面这个例子不大好，使用了Java线程已经抛弃的方法</p><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/2.png" class title="This is an image"><p>打印结果如下，最开始没奶茶，后来有了奶茶通知了挂起的线程，那个线程就得以继续执行</p><center><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/3.png" class title="This is an image"></center><p>上面这个就是经典的生产者-消费者模型，但是为啥这个例子当中的线程方法被弃用了呢？往下看一个例子</p><center>suspend和resume加锁导致死锁</center><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/4.png" class title="This is an image"><center>打印结果</center><center><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/5.png" class title="This is an image"></center><p>这个线程不用等了，一直都是在这里挂起了，竞争不到锁，没办法通知挂起的线程继续执行;</p><p>如果suspend比resume慢执行，也会导致线程永久挂起</p><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/6.png" class title="This is an image"><center>打印结果，通知完了，那边才开始挂起</center><center><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/7.png" class title="This is an image"></center><center>那么Java现在推荐哪一种方式进行使用呢~</center><center>wait/notify机制</center><p>这个机制要求这两个方法只能由同一对象锁的持有者线程进行调用，也就是卸载同步代码块里面，否则会抛出</p><center>IllegalMonitorStateException异常</center><p>wait方法导致当前的线程进入等待状态，加入该对象的等待集合中，并发放弃当前持有的对象锁;</p><p>notify/notifyAll方法唤醒一个或所有正在等待这个对象锁的线程;</p><p>注意：虽然会wait自动解锁，但是对顺序有要求，如果在notify被调用之后才开始wait方法的调用，线程会永远处于WAITING状态</p><center>先来一个正常的演示（打印跟前面正常的一致）</center><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/8.png" class title="This is an image"><center>可以看到，如果是suspend/resume的话，这个程序是会导致死锁的，可是这里采用的是wait/notify机制，会自动释放锁</center><center>如果notify比waiting先执行</center><center>那么会导致线程一直处于WAITING的状态</center><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/9.png" class title="This is an image"><center></center>说个题外话，我觉得这个就跟你的女神已经通知你，我们不可能在一起了，然后你还一直在等待<center>还有另外一个机制</center><center><font color=" #FF8C00">park/unpark机制</font></center><center>park表示等待一个“许可”</center><center>unpark表示授予一个"许可"</center><center>park/unpark机制有一个好处就是如果提前颁发“许可”了</center><center>也不会导致线程一直处于挂起或者是死锁的转态</center><center>但是它不会主动去释放锁</center><center>unpark比park提前执行的例子</center><center><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/10.png" class title="This is an image"></center><center>加锁导致死锁的例子</center><center><img src="/2020/06/12/%E3%80%90%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/11.png" class title="This is an image"></center><center><font color=" #00FA9A">【总结】</font></center><center><font color=" #FF8C00">suspend/resume机制</font></center><center>resume先执行，suspend慢执行;resume/suspend加锁;都会导致死锁</center><center>wait/notify机制</center><center>wait/notify加锁了会自动释放锁，但是notify比wait先执行依然会线程永久挂起</center><center><font color=" #FF8C00">park/unpark机制</font></center><p>park/unpark不会自动释放锁，但是先后执行顺序不会导致线程永久挂起</p><center><font color=" #FF8C00">【提醒】</font></center><center><font color=" #FF8C00">代码当中使用if语句来判断是否进入等待状态</font></center><center>是错误的</center><center>官方建议是采用<font color="#00FA9A">while</font>情况下，判断是否可以将线程挂起</center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-生产者消费者模型介绍&quot;&gt;&lt;a href=&quot;#1-生产者消费者模型介绍&quot; class=&quot;headerlink&quot; title=&quot;1.生产者消费者模型介绍&quot;&gt;&lt;/a&gt;1.生产者消费者模型介绍&lt;/h2&gt;&lt;p&gt;  &lt;font color=&quot; #FF8C00&quot;&gt;生产者消费
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【Java设计模式】代理模式</title>
    <link href="https://waibizi.github.io/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://waibizi.github.io/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-10T18:21:31.000Z</published>
    <updated>2020-06-10T18:36:11.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java代理模式的基本介绍"><a href="#1-Java代理模式的基本介绍" class="headerlink" title="1.Java代理模式的基本介绍"></a>1.Java代理模式的基本介绍</h2><p>  首先得跟大家说明白，本篇文章的设计模式实现是基于<font color="#00FA9A">Java语言</font>的，思想还是代理的思想，不要纠结于我为什么将静态代理，动态代理，cglib代理分开来说（只能说技术是技术，思想是思想）</p><p><font color=" #FF8C00">代理模式：</font>为一个对象提供一个替身，以控制对这个对象的访问;即通过代理对象访问目标对象;这样做的好处是可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能;</p><p>被代理的对象可以是<font color=" #FF8C00">远程的对象</font>、开销大的对象或者需要被安全控制保护的对象;</p><p>Java的手段实现代理模式的手段主要有三种：<font color="#00FA9A">静态代理，动态代理（JDK代理、接口代理）和cglib代理（cglib代理主要是可以在内存中创建对象，不用实现接口）</font></p><center>代理模式的类图如下</center><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/1.png" class title="This is an image"><p>  我们要调用<font color="#00FA9A">TargetObject类</font>，也就是目标类的时候，我们（Client）采用调用代理(ProxyObject)的方式去调用最终目标类，进而达到隐藏真正目标类</p><h2 id="2-Java实现静态代理"><a href="#2-Java实现静态代理" class="headerlink" title="2.Java实现静态代理"></a>2.Java实现静态代理</h2><p>静态代理：静态代理在使用的时候，需要定义接口或者是父类，被代理对象（即目标对象TargetObject）与代理对象（ProxyObject）一起实现相同的接口或者是继承相同的父类</p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/2.png" class title="This is an image"><p>类图的意思：假如我是客户（Client）我要去租房，我找到了租房中介（RentingProxy），租房中介与房东（Renting）之间签订了一定的约束，也就是条约。这是采用IRenting来约束;然后我需要租房的时候，只需要找到租房中间去租房就行了，我知道我要租哪间房，我直接调用租房中介有的方法，而租房中介可以帮我处理一些增强方法，例如会提前帮我去看房子合不合格之类的（称之为增强方法）;</p><p>代码如下：</p><center>包结构</center><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/3.png" class title="This is an image"><p>客户端类，创建了目标对象，创建了代理对象，然后将目标对象交付给代理对象，使用代理对象执行方法;</p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/4.png" class title="This is an image"><center>目标对象与代理对象应该遵守的合约</center><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/5.png" class title="This is an image"><center><font color="#00FA9A">目标对象</font></center><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/6.png" class title="This is an image"><p>代理对象，我们可以做一些增强操作</p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/7.png" class title="This is an image"><p>Client启动，执行main方法打印</p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/8.png" class title="This is an image"><h2 id="3-JDK代理"><a href="#3-JDK代理" class="headerlink" title="3.JDK代理"></a>3.JDK代理</h2><p>这里顺便介绍一下动态代理</p><p>1.代理对象，不需要实现接口，但是目标对象需要实现接口，</p><p> 否则不能使用动态代理</p><p>2.代理对象的生成，是利用了JDK的API，动态地在内存中构建</p><p> 对象</p><p>3.动态代理也叫：<font color=" #FF8C00">JDK代理、接口代理</font></p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/9.png" class title="This is an image"><p>采用的案例还是上面那个租房子的案例</p><center><font color=" #FF8C00">包结构</font></center><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/10.png" class title="This is an image"><center><font color=" #FF8C00">Client类</font></center><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/11.png" class title="This is an image"><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/12.png" class title="This is an image"><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/13.png" class title="This is an image"><p>这里的JDK动态代理可能会比较难懂，参数的意义我已经加上了</p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/14.png" class title="This is an image"><h2 id="4-Cglib代理"><a href="#4-Cglib代理" class="headerlink" title="4.Cglib代理"></a>4.Cglib代理</h2><p>1.静态代理和JDK动态代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可使用目标对象子类来实现代理，这就是Cglib代理;</p><p>2.Cglib代理也叫子类代理，他是在内存中构建一个子类对象从而实现对象功能扩展;</p><p>3.Cglib是一个强大的高性能代码生成包，可以在运行期间扩展Java类与实现Java接口;广泛地被许多AOP框架所使用，例如Spring AOP，实现方法拦截;</p><p>4.AOP编程当中应该如何选择代理模式</p><p>  1）.目标对象需要实现接口，用JDK代理</p><p>  2）.目标对象不需要实现接口，用Cgglib代理</p><p>5.Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类</p><center><font color=" #FF8C00">【注意】</font></center><p>需要代理的类也就是目标类不能使用final修饰</p><p>如果目标类的方法是static/final修饰的，也不能</p><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/15.png" class title="This is an image"><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/16.png" class title="This is an image"><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/17.png" class title="This is an image"><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/18.png" class title="This is an image"><img src="/2020/06/11/%E3%80%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/19.png" class title="This is an image">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Java代理模式的基本介绍&quot;&gt;&lt;a href=&quot;#1-Java代理模式的基本介绍&quot; class=&quot;headerlink&quot; title=&quot;1.Java代理模式的基本介绍&quot;&gt;&lt;/a&gt;1.Java代理模式的基本介绍&lt;/h2&gt;&lt;p&gt;  首先得跟大家说明白，本篇文章的设
      
    
    </summary>
    
    
      <category term="-设计模式" scheme="https://waibizi.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="-Java -设计模式" scheme="https://waibizi.github.io/tags/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>再谈自动装箱(AutoBoxing)，自动拆箱(Unboxing)</title>
    <link href="https://waibizi.github.io/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/"/>
    <id>https://waibizi.github.io/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/</id>
    <published>2020-06-09T14:49:29.000Z</published>
    <updated>2020-06-09T15:03:19.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h2><p>  自动装箱就是自动将基本数据类型转换为<strong>包装器类型</strong>；自动拆箱就是自动将包装器类型转换为<strong>基本数据类型</strong>。</p><p>  ps：Integer自动转换为<strong><font color=" #FF8C00">int</font></strong>类型，这个就是自动拆箱的过程，int自动转换为Integer就是装箱的过程。</p><img src="/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/1.png" class title="This is an image"><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h2><p>  概念不难理解，不如尝试反编译一下，看下底层是什么什么吧。</p><p>  废话少说，直接动手肝</p><p>点击查看大图</p><img src="/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/2.png" class title="This is an image"><p>  通过<strong><font color=" #FF8C00">反编译字节码</font></strong>可以很明显地看到一些效果，将<strong><font color=" #FF8C00">装箱与拆箱</font></strong>的过程反映了出来。</p><h2 id="3-自动装箱与拆箱的一些验证"><a href="#3-自动装箱与拆箱的一些验证" class="headerlink" title="3.自动装箱与拆箱的一些验证"></a>3.自动装箱与拆箱的一些验证</h2><img src="/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/3.png" class title="This is an image"><p>打印结果是<strong><font color=" #FF8C00">true</font></strong>，此步进行了自动拆箱操作</p><p><font color="#00FA9A">拆箱</font>的验证，可以通过<font color="#00FA9A">字节码</font>看到</p><img src="/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/4.png" class title="This is an image"><center>再来一次，这次使用<font color="#00FA9A">equals</font>,可以看到是装箱了</center><img src="/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/5.png" class title="This is an image"><p>具体原因是因为jdk内部使用equals的时候，传入是Object，int类型赋值到Object的时候是装箱的过程</p><img src="/2020/06/09/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-AutoBoxing-%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-Unboxing/6.png" class title="This is an image"><p><strong>小结</strong></p><p>1.自动装箱与自动装箱虽然在使用当中可以省略很多不用考虑的因素，但是这是因为Java自己做了这部分的工作（只是你看不到）;</p><p>2.大量使用自动装箱会影响一部分的性能（因为要生成Object类型）;</p><p>3.采用‘==’与‘equals’的时候，自动装箱与自动拆箱的原因为啥不同;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-基础概念&quot;&gt;&lt;a href=&quot;#1-基础概念&quot; class=&quot;headerlink&quot; title=&quot;1.基础概念&quot;&gt;&lt;/a&gt;1.基础概念&lt;/h2&gt;&lt;p&gt;  自动装箱就是自动将基本数据类型转换为&lt;strong&gt;包装器类型&lt;/strong&gt;；自动拆箱就是自动将包装
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【CAS基础】CAS简单入门</title>
    <link href="https://waibizi.github.io/2020/06/09/%E3%80%90CAS%E5%9F%BA%E7%A1%80%E3%80%91CAS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"/>
    <id>https://waibizi.github.io/2020/06/09/%E3%80%90CAS%E5%9F%BA%E7%A1%80%E3%80%91CAS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</id>
    <published>2020-06-09T13:42:43.000Z</published>
    <updated>2020-06-09T14:47:29.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-CAS概念"><a href="#1-CAS概念" class="headerlink" title="1.CAS概念"></a>1.CAS概念</h2><p>  首先，跟大家强调一下，CAS是一种思想！！一种思想！！一种思想！！！（重要的话说三次）</p><p>  CAS的的英文全称<strong><font color=" #FF8C00">Compare-and-Swap</font></strong>，中文名称叫做比较并交换，一种才不采用强制性锁机制下的一种值更新策略；在并发的情况下，挺多情况是直接synchronized跟voliate或者其他锁机制实现并发时保证数据一致性的;</p><h2 id="2-CAS的一个小Demo"><a href="#2-CAS的一个小Demo" class="headerlink" title="2.CAS的一个小Demo"></a>2.CAS的一个小Demo</h2><p>  CAS呢，底层是在unsafe类当中的，但是JDK当中有许多类都会采用CAS去保障数据的并发问题，我们简单看一个并发包当中的类，然后去认识CAS吧;</p><img src="/2020/06/09/%E3%80%90CAS%E5%9F%BA%E7%A1%80%E3%80%91CAS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/1.png" class title="This is an image"><center>这是一个安全的int，我初始化这个int为5，然后采用了</center><center>AtomicInteger的CAS实现</center><center>大概就是expect期望值是5的话，把值改为update的值</center><center>然后我们就简单进去源码看下吧····</center><img src="/2020/06/09/%E3%80%90CAS%E5%9F%BA%E7%A1%80%E3%80%91CAS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/2.png" class title="This is an image"><p>参数的意思:</p><p><font color=" #FF8C00">this</font>：当前对象</p><p><font color=" #FF8C00">valueOffset</font>：内存地址</p><p><font color=" #FF8C00">expect</font>：期待值</p><p><font color=" #FF8C00">update</font>：更新值</p><p>再往下看就不是我们此时关注的重点啦，因为再往下就是unsafe类</p><p>这个类我会的后续再写一篇介绍</p><p>（真的是太多了）</p><h2 id="3-CAS的缺点以及ABA问题"><a href="#3-CAS的缺点以及ABA问题" class="headerlink" title="3.CAS的缺点以及ABA问题"></a>3.CAS的缺点以及ABA问题</h2><p>  <font color="#7B68EE" size="5">无锁机制固然好，但是有一些比较明显的缺点也随着带来了，我们先来简单说一下CAS当中自旋出现的问题;</font></p><p>假设我现在有两个线程：线程A与线程B，然后有一个变量，表示的是卡上的余额;</p><p>线程A，此时知道的初始值是50元，线程B也是晓得此时初始值是50元：</p><p>线程A想把50更新为100，线程B想把50更新为零，那么此时线程A与线程B的“期望值”都是50，线程A的运气比较好，先抢占到时间片，开始更新数据，并且更新数据成功。而线程B因为一些中间处理操作，需要时间等待，此时拿着期望值“50”，进行CAS比较交换的时候，发现期望值无效，于是重新获取了一次最新的“真实值”，然后很不凑巧，线程A此时又想修改值，而且时间片也被线程A抢占了，线程A此时拿着最新的期望值是“100”，又更新成功了，把值重新改回50，而线程B这倒霉蛋又拿着期望值为“100”的，想过来修改值，又没办法修改···</p><p>如果线程B一直运气不好，抢不到时间片，就会导致线程B一直处于自旋的状态···</p><p>【ABA问题】</p><p>ABA问题比较好理解</p><p>  1.线程A，期望值是50，欲更新值为100</p><p>  2.线程B，期望值是50，欲更新值为100</p><p>  线程A首先拿到时间片，进行值的更新，此时线程B因为某些问题（阻塞了一段时间），没有抢占到时间片。此时A更新了值了，然后突然来了一个线程C，比线程B先抢占到了时间片（线程B挺可怜的），此时线程C的期望值是100，欲修改值是50，CAS执行成功了，此时线程B终于阻塞完了，拿着期望值为50，更新值为100的操作姗姗来迟，此时CAS也成功了。可是线程B并不知道他自己修改了的值是经过了50-&gt;100-&gt;50-&gt;100。除开掉前面的50是初始值，100,50,100三个数就是ABA的代表，可以将100替换为A理解，50替换为B理解。</p><p>这个ABA会导致什么问题的出现呢？</p><p>如果说此时我的银行卡收入了50元，卡内原先余额为50元，此时就要更新为100元，由于一些比较特殊的原因（难不成是工程师的锅），此时50欲更新为100有两条线程，就跟上面例子一样;然后此时突然我的女朋友想要花我的银行卡的钱，我的银行卡也需要扣费了，三个线程出现了上面那种执行顺序问题，我的卡此时不就白白赚了50块钱了吗？（可能例子不大恰当，但是ABA当中就是这种问题的发生）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-CAS概念&quot;&gt;&lt;a href=&quot;#1-CAS概念&quot; class=&quot;headerlink&quot; title=&quot;1.CAS概念&quot;&gt;&lt;/a&gt;1.CAS概念&lt;/h2&gt;&lt;p&gt;  首先，跟大家强调一下，CAS是一种思想！！一种思想！！一种思想！！！（重要的话说三次）&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="-Java基础" scheme="https://waibizi.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="CAS" scheme="https://waibizi.github.io/tags/CAS/"/>
    
      <category term="Java" scheme="https://waibizi.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
