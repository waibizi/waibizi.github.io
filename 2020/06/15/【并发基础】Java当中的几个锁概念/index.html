
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>【并发基础】Java当中的几个锁概念 - 歪鼻子</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="waibizi,"> 
    <meta name="description" content="1.前言  Java对于并发场景，对于锁的使用是最重要的，这次主要是介绍一下Java当中的锁类别与场景：公平锁、非公平锁、乐观锁、悲观锁、偏向锁、轻量级锁、重量级锁、自旋锁、读写锁、锁粗化/锁消除、,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="歪鼻子" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="loading">
    <span id="config-title" style="display:none">歪鼻子</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://waibizi.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">【并发基础】Java当中的几个锁概念</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">【并发基础】Java当中的几个锁概念</h1>
        <div class="stuff">
            <span>六月 15, 2020</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E9%94%81%E6%9C%BA%E5%88%B6/" rel="tag">-锁机制</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>  Java对于并发场景，对于锁的使用是最重要的，这次主要是介绍一下Java当中的锁类别与场景：公平锁、非公平锁、乐观锁、悲观锁、偏向锁、轻量级锁、重量级锁、自旋锁、读写锁、锁粗化/锁消除、分段锁;</p>
<h2 id="2-公平锁与非公平锁"><a href="#2-公平锁与非公平锁" class="headerlink" title="2.公平锁与非公平锁"></a>2.公平锁与非公平锁</h2><p>  正如锁的名字所言，他们的要点就是在于公平或者非公平的这两个意思身上;</p>
<p>  假设我们有如下场景，Thread-1获得锁之后，其他线程如果需要获得锁，不管是公平还是非公平都是需要在外等待的;</p>
<center><font color=" #FF8C00">（注意，这里Thread-2到Thread-4是依次到达来等待锁的）</font></center>

<p>  那么接下来的场景就是体现公平锁跟非公平锁的时候了，Thread-1已经释放锁了，而剩下的几个线程都需要这个锁，那么应该怎么去分配锁呢？</p>
<p>  如果是公平锁，那么就是多来了一个线程，也得去队列当中待着，按照线程来竞争锁的顺序一个一个排队;</p>
<p>  如果是非公平锁的话，在Thread-2到Thread-4之间，他们去竞争这把锁的机会是同等的，也就是他们不用排队等待，谁竞争到了就先持有锁;</p>
<center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/1.jpg" class title="This is an image"></center>

<p>实现例子：</p>
<p>注意：你需要了解<b><font color=" #FF8C00">ReentrantLock</font></b>的一些常识，例如这是一个可重入的锁，而且默认是非公平锁;</p>
<center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/2.png" class title="This is an image"></center>

<center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/3.png" class title="This is an image"></center>

<center>然后我们运行一下吧</center>

<center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/4.png" class title="This is an image"></center>

<center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/5.png" class title="This is an image"></center>

<center>我们开始start的时候，肯定是外部线程先进去等待了</center>

<center>然后再内部锁进去了等待，那么如果是公平锁</center>

<center>就是大家一起按顺序慢慢等</center>

<center>那么非公平肯定就没有顺序的啦</center>

<center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/6.png" class title="This is an image"></center>

<center>这个位置改一下</center>

<center>然后再次运行就可以看到内部与外部的输出是交替的</center>

<center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/7.png" class title="This is an image"></center>

<center>我这里就随便截图一个输出就行了</center>

<center>可以看到是交替的进行的</center>

<center>也就是不用按照线程去竞争锁的排队顺序的</center>



<center>大多数锁机制都是默认为非公平锁的</center>

<center>因为非公平锁有着比公平锁更好的性能</center>

<center>由于线程的上下文切换浪费性能</center>

<center>以及需要等待排队线程的唤醒操作等等都会影响浪费性能</center>

<h2 id="3-读写锁"><a href="#3-读写锁" class="headerlink" title="3.读写锁"></a>3.读写锁</h2><p>  大多数的人刚开始接触的锁其实都是属于排他锁，也就是线程独占锁，一旦线程占有这把锁的话，其他线程的任何操作想获取锁都是没办法获取的;</p>
<p>  然而在一些特定的场景下，我们并不希望一旦一个线程占有了这个锁，就无法进行其他的操作;</p>
<p>  <b><font color=" #00FA9A">读写锁</font></b>：也就是读写锁分离。读锁可以在没有写锁的时候，被多个线程共同占用，而写锁是独占的，也就是只能由一个线程去占用这把锁;</p>
<center>互斥的原则是</center>

<center>多个线程都是读的时候，都是可以共同持有锁</center>

<center>有一个写操作的时候，其他线程<font color=" #00FA9A">不能读也不能写</font></center>


<center>这里我们模拟一个队列，队列里面有写入操作与读取操作</center>

<center>在写入操作与读取操作的时候，我们分别加上写锁与读锁</center>

<center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/8.png" class title="This is an image"></center>

<center>编写main方法测试</center>

<center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/9.png" class title="This is an image"></center>



<center>我们从前面的理论知识推断，在读取的时候，</center>


<center>写操作是不能<font color=" #FF8C00">直接插入</font>的，因为是<b><font color=" #FF8C00">互斥的</font></b></center>

<center>也就是写操作的时候，必须在某一个时机</center>

<center>恰好！！读操作释放了锁，写操作接着占用了这把锁</center>

<center><font color=" #FF8C00">看下运行结果吧</font></center>

<center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/10.png" class title="This is an image"></center>



<center>上面的demo只是为了验证锁</center>

<center>我们学习东西主要是为了使用</center>

<center>这个锁在缓存场景其实很适用的</center>


<p>回顾一下我们的缓存场景：不就是写的操作比较少，读的情况比较多，我们为了提高速度将缓存放置到内存当中嘛？</p>
<p>为了方便模拟的策略，我们先说一下我们要实现的一个小例子：我们模拟在缓存场景下，如果值存在，我们就直接get返回，并且这个get操作是多个线程可以共享的;如果值不存在的情况，多个线程只能有一个线程去获取到锁，并且触发查询数据库的操作;</p>
<center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/11.png" class title="This is an image"></center>



<h2 id="4-自旋锁"><a href="#4-自旋锁" class="headerlink" title="4.自旋锁"></a>4.自旋锁</h2><p>  有的时候我们加上一些lock操作的时候，会导致上下文切换浪费性能，因为需要上锁再释放锁，有一些持有锁的时间比较短的情况下，我们可以采用<b><font color=" #00FA9A">自旋锁</font></b>;</p>
<p>  <b><font color=" #00FA9A">自旋锁</font></b>，顾名思义，自我“旋转”就变成了锁，这个自我旋转指的是去旋转CPU的时间片，不上锁的情况让线程在那里进行空转;</p>
<p>我们简单看一下需求，如果说主线程的那句打印，我们需要在所有的线程执行完毕之后再开始执行的话，不加lock的情况，我们应该怎么去操作;</p>
<img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/12.png" class title="This is an image">


<center>上面代码的执行时打印这样，还没有加自旋锁的情况的</center>


<center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/13.png" class title="This is an image"></center>


<p>这里由于我的编码工具的缘故，所以我自旋的时候判断线程数目采用了2，不过这不是关键啦，主要是看下自旋的思想</p>
<center><img src="/2020/06/15/%E3%80%90%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%91Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%94%81%E6%A6%82%E5%BF%B5/14.png" class title="This is an image"></center>


<h2 id="5-偏向锁"><a href="#5-偏向锁" class="headerlink" title="5.偏向锁"></a>5.偏向锁</h2><p>  <b><font color=" #FF8C00">偏向锁</font></b>，在synchronized锁升级时候，有去看到锁升级的采用了偏向锁，至于偏向锁怎么去实现，笔者暂时不清楚怎么去实现;</p>
<p>  <b><font color=" #00FA9A">偏向锁</font></b>主要用于大多数情况是一个线程去竞争这把锁的情况，也就是这个锁在大多数情况下，只有一个线程去多次获得。一旦有多个线程来<b><font color=" #00FA9A">竞争锁</font></b>了，偏向锁都会升级为其他锁的;</p>
<h2 id="6-其他几个锁的概念"><a href="#6-其他几个锁的概念" class="headerlink" title="6.其他几个锁的概念"></a>6.其他几个锁的概念</h2><p>  <b><font color=" #FF8C00">悲观锁</font></b>：例如synchronized加锁的情况，就是属于悲观锁，悲观锁，顾名思义，就是比较悲观，每一次我们都必须加锁;</p>
<p>  <b><font color=" #FF8C00">乐观锁</font></b>：就是比较少竞争的情况，我们没有进行加锁操作，如果竞争比较严重的时候，我们就对其进行加锁，这个取决于你怎么去实现;</p>
<p>  <b><font color=" #FF8C00">重量级锁</font></b>：synchronized就是一把重量级锁，但是synchronized没有那么低效率了，锁升级的过程让synchronized这把有着重量级锁的性能得到了提升;</p>
<p>  <b><font color=" #FF8C00">轻量级锁</font></b>：当偏向锁升级成轻量级锁的时候，我们称这种机制是轻量级锁;</p>
<p>  <b><font color=" #FF8C00">分段锁</font></b>：并发包下，例如常见的ConcurrentHashMap里面就采用了分段锁，主要是根据锁的位置不是大面积的情况，进行分段加锁;</p>
<p>  <b><font color=" #FF8C00">锁粗化</font></b>：如果说加锁位置是一大块的位置，没有更细粒度去加锁位置的话，就是锁粗化;</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='https://m10.music.126.net/20200718132507/2accc18c98a561b7ffee6caa688f0fab/yyaac/010c/070e/0752/6f2a8bb6520de4301bab087cbce98087.m4ap3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o='歪鼻子'
        data-a='waibizi'
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-前言"><span class="toc-number">1.</span> <span class="toc-text">1.前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-公平锁与非公平锁"><span class="toc-number">2.</span> <span class="toc-text">2.公平锁与非公平锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-读写锁"><span class="toc-number">3.</span> <span class="toc-text">3.读写锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-自旋锁"><span class="toc-number">4.</span> <span class="toc-text">4.自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-偏向锁"><span class="toc-number">5.</span> <span class="toc-text">5.偏向锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-其他几个锁的概念"><span class="toc-number">6.</span> <span class="toc-text">6.其他几个锁的概念</span></a></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
