[{"title":"【Java设计模式】代理模式","url":"/2020/06/11/【Java设计模式】代理模式/","content":"\n## 1.Java代理模式的基本介绍\n\n\n  首先得跟大家说明白，本篇文章的设计模式实现是基于<font color=\"#00FA9A\">Java语言</font>的，思想还是代理的思想，不要纠结于我为什么将静态代理，动态代理，cglib代理分开来说（只能说技术是技术，思想是思想）\n\n<font color=\" #FF8C00\">代理模式：</font>为一个对象提供一个替身，以控制对这个对象的访问;即通过代理对象访问目标对象;这样做的好处是可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能;\n\n被代理的对象可以是<font color=\" #FF8C00\">远程的对象</font>、开销大的对象或者需要被安全控制保护的对象;\n\n\nJava的手段实现代理模式的手段主要有三种：<font color=\"#00FA9A\">静态代理，动态代理（JDK代理、接口代理）和cglib代理（cglib代理主要是可以在内存中创建对象，不用实现接口）</font>\n\n\n\n<center>代理模式的类图如下</center>\n\n{% asset_img 1.png This is an image %}\n\n\n  我们要调用<font color=\"#00FA9A\">TargetObject类</font>，也就是目标类的时候，我们（Client）采用调用代理(ProxyObject)的方式去调用最终目标类，进而达到隐藏真正目标类\n\n\n\n## 2.Java实现静态代理\n\n\n\n静态代理：静态代理在使用的时候，需要定义接口或者是父类，被代理对象（即目标对象TargetObject）与代理对象（ProxyObject）一起实现相同的接口或者是继承相同的父类\n\n{% asset_img 2.png This is an image %}\n\n\n类图的意思：假如我是客户（Client）我要去租房，我找到了租房中介（RentingProxy），租房中介与房东（Renting）之间签订了一定的约束，也就是条约。这是采用IRenting来约束;然后我需要租房的时候，只需要找到租房中间去租房就行了，我知道我要租哪间房，我直接调用租房中介有的方法，而租房中介可以帮我处理一些增强方法，例如会提前帮我去看房子合不合格之类的（称之为增强方法）;\n\n代码如下：\n\n<center>包结构</center>\n\n{% asset_img 3.png This is an image %}\n\n客户端类，创建了目标对象，创建了代理对象，然后将目标对象交付给代理对象，使用代理对象执行方法;\n\n{% asset_img 4.png This is an image %}\n\n<center>目标对象与代理对象应该遵守的合约</center>\n\n{% asset_img 5.png This is an image %}\n\n<center><font color=\"#00FA9A\">目标对象</font></center>\n\n{% asset_img 6.png This is an image %}\n\n代理对象，我们可以做一些增强操作\n\n{% asset_img 7.png This is an image %}\n\nClient启动，执行main方法打印\n\n{% asset_img 8.png This is an image %}\n\n## 3.JDK代理\n\n\n\n这里顺便介绍一下动态代理\n\n1.代理对象，不需要实现接口，但是目标对象需要实现接口，\n\n 否则不能使用动态代理\n\n2.代理对象的生成，是利用了JDK的API，动态地在内存中构建\n\n 对象\n\n3.动态代理也叫：<font color=\" #FF8C00\">JDK代理、接口代理</font>\n\n{% asset_img 9.png This is an image %}\n\n采用的案例还是上面那个租房子的案例\n\n\n<center><font color=\" #FF8C00\">包结构</font></center>\n\n{% asset_img 10.png This is an image %}\n\n<center><font color=\" #FF8C00\">Client类</font></center>\n\n{% asset_img 11.png This is an image %}\n\n{% asset_img 12.png This is an image %}\n\n{% asset_img 13.png This is an image %}\n\n这里的JDK动态代理可能会比较难懂，参数的意义我已经加上了\n\n\n{% asset_img 14.png This is an image %}\n\n## 4.Cglib代理\n\n\n\n1.静态代理和JDK动态代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可使用目标对象子类来实现代理，这就是Cglib代理;\n\n2.Cglib代理也叫子类代理，他是在内存中构建一个子类对象从而实现对象功能扩展;\n\n3.Cglib是一个强大的高性能代码生成包，可以在运行期间扩展Java类与实现Java接口;广泛地被许多AOP框架所使用，例如Spring AOP，实现方法拦截;\n\n4.AOP编程当中应该如何选择代理模式\n\n  1）.目标对象需要实现接口，用JDK代理\n\n  2）.目标对象不需要实现接口，用Cgglib代理\n\n5.Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类\n\n<center><font color=\" #FF8C00\">【注意】</font></center>\n\n需要代理的类也就是目标类不能使用final修饰\n\n如果目标类的方法是static/final修饰的，也不能\n\n{% asset_img 15.png This is an image %}\n\n{% asset_img 16.png This is an image %}\n\n{% asset_img 17.png This is an image %}\n\n{% asset_img 18.png This is an image %}\n\n{% asset_img 19.png This is an image %}","tags":["-Java -设计模式"],"categories":["-设计模式"]},{"title":"再谈自动装箱(AutoBoxing)，自动拆箱(Unboxing)","url":"/2020/06/09/再谈自动装箱-AutoBoxing-，自动拆箱-Unboxing/","content":"\n## 1.基础概念\n\n  自动装箱就是自动将基本数据类型转换为**包装器类型**；自动拆箱就是自动将包装器类型转换为**基本数据类型**。\n\n  ps：Integer自动转换为**<font color=\" #FF8C00\">int</font>**类型，这个就是自动拆箱的过程，int自动转换为Integer就是装箱的过程。\n\n{% asset_img 1.png This is an image %}\n\n## 2.原理\n\n  概念不难理解，不如尝试反编译一下，看下底层是什么什么吧。\n\n  废话少说，直接动手肝\n\n点击查看大图\n\n{% asset_img 2.png This is an image %}\n\n  通过**<font color=\" #FF8C00\">反编译字节码</font>**可以很明显地看到一些效果，将**<font color=\" #FF8C00\">装箱与拆箱</font>**的过程反映了出来。\n\n## 3.自动装箱与拆箱的一些验证\n\n{% asset_img 3.png This is an image %}\n\n打印结果是**<font color=\" #FF8C00\">true</font>**，此步进行了自动拆箱操作\n\n<font color=\"#00FA9A\">拆箱</font>的验证，可以通过<font color=\"#00FA9A\">字节码</font>看到\n\n{% asset_img 4.png This is an image %}\n\n<center>再来一次，这次使用<font color=\"#00FA9A\">equals</font>,可以看到是装箱了</center>\n\n{% asset_img 5.png This is an image %}\n\n具体原因是因为jdk内部使用equals的时候，传入是Object，int类型赋值到Object的时候是装箱的过程\n\n{% asset_img 6.png This is an image %}\n\n**小结**\n\n1.自动装箱与自动装箱虽然在使用当中可以省略很多不用考虑的因素，但是这是因为Java自己做了这部分的工作（只是你看不到）;\n\n2.大量使用自动装箱会影响一部分的性能（因为要生成Object类型）;\n\n3.采用‘==’与‘equals’的时候，自动装箱与自动拆箱的原因为啥不同;"},{"title":"【CAS基础】CAS简单入门","url":"/2020/06/09/【CAS基础】CAS简单入门/","content":"\n## 1.CAS概念\n\n  首先，跟大家强调一下，CAS是一种思想！！一种思想！！一种思想！！！（重要的话说三次）\n\n  CAS的的英文全称**<font color=\" #FF8C00\">Compare-and-Swap</font>**，中文名称叫做比较并交换，一种才不采用强制性锁机制下的一种值更新策略；在并发的情况下，挺多情况是直接synchronized跟voliate或者其他锁机制实现并发时保证数据一致性的;\n\n## 2.CAS的一个小Demo\n\n  CAS呢，底层是在unsafe类当中的，但是JDK当中有许多类都会采用CAS去保障数据的并发问题，我们简单看一个并发包当中的类，然后去认识CAS吧;\n\n{% asset_img 1.png This is an image %}\n\n<center>这是一个安全的int，我初始化这个int为5，然后采用了</center>\n\n<center>AtomicInteger的CAS实现</center>\n\n<center>大概就是expect期望值是5的话，把值改为update的值</center>\n\n\n\n<center>然后我们就简单进去源码看下吧····</center>\n\n{% asset_img 2.png This is an image %}\n\n\n\n参数的意思:\n\n\n<font color=\" #FF8C00\">this</font>：当前对象\n\n<font color=\" #FF8C00\">valueOffset</font>：内存地址\n\n<font color=\" #FF8C00\">expect</font>：期待值\n\n<font color=\" #FF8C00\">update</font>：更新值\n\n再往下看就不是我们此时关注的重点啦，因为再往下就是unsafe类\n\n这个类我会的后续再写一篇介绍\n\n（真的是太多了）\n\n\n\n## 3.CAS的缺点以及ABA问题\n\n\n  <font color= #7B68EE size=5>无锁机制固然好，但是有一些比较明显的缺点也随着带来了，我们先来简单说一下CAS当中自旋出现的问题;</font>\n\n\n假设我现在有两个线程：线程A与线程B，然后有一个变量，表示的是卡上的余额;\n\n\n\n线程A，此时知道的初始值是50元，线程B也是晓得此时初始值是50元：\n\n线程A想把50更新为100，线程B想把50更新为零，那么此时线程A与线程B的“期望值”都是50，线程A的运气比较好，先抢占到时间片，开始更新数据，并且更新数据成功。而线程B因为一些中间处理操作，需要时间等待，此时拿着期望值“50”，进行CAS比较交换的时候，发现期望值无效，于是重新获取了一次最新的“真实值”，然后很不凑巧，线程A此时又想修改值，而且时间片也被线程A抢占了，线程A此时拿着最新的期望值是“100”，又更新成功了，把值重新改回50，而线程B这倒霉蛋又拿着期望值为“100”的，想过来修改值，又没办法修改···\n\n\n\n如果线程B一直运气不好，抢不到时间片，就会导致线程B一直处于自旋的状态···\n\n\n【ABA问题】\n\nABA问题比较好理解\n\n  1.线程A，期望值是50，欲更新值为100\n\n  2.线程B，期望值是50，欲更新值为100\n\n\n  线程A首先拿到时间片，进行值的更新，此时线程B因为某些问题（阻塞了一段时间），没有抢占到时间片。此时A更新了值了，然后突然来了一个线程C，比线程B先抢占到了时间片（线程B挺可怜的），此时线程C的期望值是100，欲修改值是50，CAS执行成功了，此时线程B终于阻塞完了，拿着期望值为50，更新值为100的操作姗姗来迟，此时CAS也成功了。可是线程B并不知道他自己修改了的值是经过了50->100->50->100。除开掉前面的50是初始值，100,50,100三个数就是ABA的代表，可以将100替换为A理解，50替换为B理解。\n\n\n这个ABA会导致什么问题的出现呢？\n\n\n如果说此时我的银行卡收入了50元，卡内原先余额为50元，此时就要更新为100元，由于一些比较特殊的原因（难不成是工程师的锅），此时50欲更新为100有两条线程，就跟上面例子一样;然后此时突然我的女朋友想要花我的银行卡的钱，我的银行卡也需要扣费了，三个线程出现了上面那种执行顺序问题，我的卡此时不就白白赚了50块钱了吗？（可能例子不大恰当，但是ABA当中就是这种问题的发生）","tags":["CAS","Java"],"categories":["-Java基础"]}]