[{"title":"【Java的IO模型】BIO、NIO基础入门","url":"/2020/07/12/【Java的IO模型】BIO、NIO基础入门/","content":"\n## 一、IO模型\n\n<center>作为一个Java开发者，对于IO模型是绕不开的一环：所谓的IO模型，就是你采用什么的通道模型进行数据的接收与发送</center>\n\n<center>Java的网络编程的IO模型主要有：BIO、NIO</center>\n\n<center>本篇主要是学一下BIO与NIO的基础</center>\n\n## 二、什么是BIO\n\n<center> Java BIO英文名称是<font color=\"#FF33FF\">Java Blocking IO</font>,顾名思义就是Java的阻塞IO模型;</center>\nBIO的主要特性就是同步并阻塞（传统阻塞型IO），服务器在接收到一个连接的时就会给这个连接分配线程，也就是每一个连接都需要启动一个线程进行处理;如果这个连接此时没有任何操纵的情况，只要还在连接当中的话，就会一直占用着这个线程;这里我们可以想一下，如果QQ采用的是BIO的话，那还得了嘛（嘿嘿）;\n<center>可是我们还是得来学一下BIO，唔····</center>\n<center>简单看一下BIO的模型图吧</center>\n{% asset_img 1.jpg This is an image %}\n\n\t在这个模型图当中，我们采用了四个连接，然后服务器就会去创建四个线程与客户端进行连接;\n\n\n<center>那么Java的BIO在哪咧···其实就是大家Java基础经常用的</center>\n<center>Java.io包下</center>\n\n    其实以前学网络编程的时候，这个我经常用不过我当时没有管这个叫BIO（今天废话有点多）;\n<center>其实以前学网络编程的时候，这个我经常用不过我当时没有管这个叫BIO（今天废话有点多）</center>\n\n<center>我们简单来看一下简单实例吧</center>\n\n```java\npackage com.waibizi;\n\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.*;\n\n/**\n * @Author 吴典秋\n * @Date 2020/6/6 13:42\n * @Description: BIO的服务端\n * @Version 1.0\n */\npublic class BioServer {\n    public static void main(String[] args) throws IOException {\n        //采用线程池机制\n        ThreadPoolExecutor threadPoolExecutor =\n                new ThreadPoolExecutor\n                        (8,16,10,\n                                TimeUnit.SECONDS,new SynchronousQueue<Runnable>(),\n                                Executors.defaultThreadFactory());\n        //创建一个端口为1024的ServerSocket\n        ServerSocket serverSocket = new ServerSocket(1024);\n        System.out.println(\"服务器启动了\");\n        while (true){\n            System.out.println(\"使服务器的线程名称为:\"+Thread.currentThread().getName());\n            //监听、等待客户端的连接\n            System.out.println(\"等待连接当中\");\n            final Socket socket = serverSocket.accept();\n            System.out.println(\"有客户端连接进来了\");\n            threadPoolExecutor.execute(()->{\n                handler(socket);\n            });\n        }\n    }\n\n    public static void handler(Socket socket){\n        try{\n            System.out.println(\"通讯的线程名称为:\"+Thread.currentThread().getName());\n            byte[] bytes = new byte[1024];\n            //通过socket获取输入流\n            InputStream inputStream = socket.getInputStream();\n            while (true){\n                System.out.println(\"进行信息交流的线程名称为:\"+Thread.currentThread().getName());\n                System.out.println(\"Reading········\");\n                int read = inputStream.read(bytes);\n                if (read!=-1){\n                    System.out.println(new String(bytes,0,read));\n                }else {\n                    break;\n                }\n            }\n        }catch(Exception e){\n            e.printStackTrace();\n        }finally {\n            System.out.println(\"关闭与客户端的连接\");\n            try {\n                socket.close();\n            }catch (Exception e){\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n<center>运行一下吧</center><br/>\n{% asset_img 2.jpg This is an image %}\n\n\n<center>我们采用telnet来连接一下就可以了</center>\n{% asset_img 3.jpg This is an image %}\n\n\n<br/>\n<br/>\n\n\n\n<center>我这里开了三个连接，可以看到创建了三个线程了</center>\n<center>然后再简单发几条消息康康吧</center>\n{% asset_img 4.jpg This is an image %}\n\n\n\n\n<center>然后程序你自己跑一遍，挂着康康你就晓得了</center>\n<center>这玩意一直在连接当中···</center>\n<center>【分析】</center>\n    BIO的案例分析当中，主要是每连接每线程的IO通信模型，在BIO当中serverSocket.accept()、serverSocket.read()、serverSocket.write()这三个方法都是同步阻塞的;\n<center>那么BIO适用于什么场景呢</center>\n     BIO的这种网络IO模型适用于连接数目比较小且固定的架构，这种方式对于服务器的配置要求会比较高，这种连接方式比较容易理解，在JDK1.4以前，BIO的通信方式是唯一的选择;\nBIO的几个要点：\n\n1.每个请求都需要创建<font color=\"#FF33FF\">独立的线程</font>，与对应的客户端进行交互;\n\n2.当并发数比较大的时候，需要创建<font color=\"#FF33FF\">大量的线程</font>来处理连接，\n\n  系统资源占用比较大（别看我已经采用了线程池机制，但是一直阻塞当中的话线程池其实作用不大的）;\n\n## 三、什么是NIO\n Java NIO全称 <font color=\" #FF8C00\">Java non-blocking IO(</font>也有人称之为New IO),是Java提供的一个全新的IO模型;NIO主要是非阻塞的同步IO，BIO是阻塞的;\n\n\n<center>NIO当中主要有三大核心功能：Channel（通道）、Buffer（缓冲区）、Selector（选择器）;</center><br/><br/>\n<center>【分享一个我听到十分好的比喻】</center><br/><br/>\n<center>Selector是中央控制器，Buffer是承载数据的容器，而Channel可以说最基础的门面，它是本地I/O设备，网络I/O的通信桥梁，只有搭建了这座桥梁，数据才能被写入Buffer，连接才能被Selector控制;</center><br/><br/>\n<center>NIO是一种非阻塞型的IO模型，也就是NIO的线程模型当中对Socket发起的连接不需要每个都创建一个线程，完全可以使用一个Selector来多路复用监听N多个Channel是否有请求，该请求是对应的连接请求，还是发送数据的请求;</center><br/><br/>\n<center>这里面是基于操作系统底层的Select通知机制的，一个Selector不断的轮询多个Channel，这样避免了创建多个线程</center><br/><br/>\n<center>具体模型图如下</center><br/><br/>\n{% asset_img 5.jpg This is an image %}\n\n\n1）每一个Channel都会对应一个Buffer；\n\n2）Select对应一个线程，一个线程对应多个Channel；\n\n3）程序切换到哪个Channel是由事件决定的；\n\n4）Buffer就是一个内存块，底层是有一个数组；\n\n5）NIO当中的Buffer是可以读又可以写的，只需要flip就可以切换;\n\n<center>说了那么多</center>\n\n<center>关于Selector、Buffer、Channel这三个概念是比较模糊的</center>\n\n<center>下面具体说说这三个</center>\n\n\n<center>【关于Selector、Buffer、Channel具体介绍】</center>\n**Selector**\n\n    Selector就是一个选择器，可以选择一个通道进行通信，这样就可以不使用那么多线程去通信，具体如下：\n\n\n1）Java的NIO，是一种非阻塞的IO交互方式。可以用于一个线程处理多个客户端连接，采用的就是选择器的机制;\n\n2）选择器可以监听多个已经注册的通道是否有时间发生，如果有事件发生，便获取事件然后针对每个事件进行想用的处理。这样就可以只用一个单线程去管理多个通道，也就是处理多个连接和请求;\n\n3）采用了<font color=\" #FF8C00\">Selector机制</font>可以在真正有读写实践的时候，才会进行读写，就大大减少了系统的开销，不必为每个连接都创建线程，不用去维护多个线程，避免了多个线程上下文切换所带来的损耗;\n\n**Channel**\n\n    Channel的意思就是通道，有点类似与流，但是有些区的不同;\n\n1）通道可以同时进行读写操作，而流要么只能读或者只能写（可以参考FileInputStream与FileOutputStream）;\n\n2）通道可以实现异步读写数据；\n\n3）通道可以从<font color=\" #FF8C00\">缓冲区</font>读数据，也可以写入数据到缓冲当中；\n\n**Buffer**\n\n    Buffer的意思就是缓冲区，缓冲区是一个读写数据的内存块，缓冲区对象内置了一些机制，可以追踪和记录缓冲区的状态变化情况;\n\n1）Java当中提供了丰富的Buffer子类（Byte,Float,int等等）;\n\n<center>谈了那么多，上上代码吧，代码的注释挺多的</center>\n<center>Server端</center>\n\n```java\npackage com.waibizi.socket;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Iterator;\nimport java.util.Set;\n\n/**\n * @Author 歪鼻子\n * @Date 2020/6/12 18:00\n * @Description:\n * @Version 1.0\n */\npublic class NIOServer {\n    public static void main(String[] args) throws IOException {\n        //创建ServerSocketChannel\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        //得到一个Selector\n        Selector selector = Selector.open();\n        //绑定一个端口666，在服务器端监听\n        serverSocketChannel.socket().bind(new InetSocketAddress(6666));\n        //设置为非阻塞,NIO就是在这个部分可以设置为非阻塞的状态\n        serverSocketChannel.configureBlocking(false);\n        //把serverSocketChannel注册到selector关联，并将Channel设置为OP_ACCEPT，OP_ACCEPT表示的就是就绪状态\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        System.out.println(\"注册后的selectionKey的数量 = \"+selector.keys().size());\n        //循环等待客户端连接\n        while (true){\n            //这里我们等待1秒，如果没有时间发生，则返回\n            if (selector.select(1000) == 0){\n                System.out.println(\"服务器等待了一秒，没有人连接\");\n                continue;\n            }\n            //如果返回的大于0，就获取到相关的selectionKey\n            //1. 如果返回的>0， 表示已经获取到关注的事件\n            //2. selector.selectedKeys() 返回关注事件的集合\n            Set<SelectionKey> selectionKeys = selector.selectedKeys();\n            System.out.println(\"SelectionKey的数量 = \"+selectionKeys.size());\n            //遍历Set<SelectionKey>，使用迭代器遍历\n            Iterator<SelectionKey> keyIterator = selectionKeys.iterator();\n            while (keyIterator.hasNext()){\n                //获取到SelectionKey\n                SelectionKey key = keyIterator.next();\n                //根据key对应的通道发生的事件做相应的处理:如果key的状态是OP_ACCEPT也就是有一个连接请求\n                if (key.isAcceptable()){\n                    //调用accept这个方法，表示可以进行TCP三次握手了\n                    SocketChannel socketChannel = serverSocketChannel.accept();\n                    System.out.println(\"客户端连接成功！生成了一个socketChannel，本地连接的socketChannel的标识码是 = \"+socketChannel.hashCode());\n                    //将SocketChannel 设置为非阻塞\n                    socketChannel.configureBlocking(false);\n                    //将socketChannel注册到selector，关注事件为OP_READ,同时给socketChannel\n                    //关联到一个Buffer\n                    socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(1024));\n                    System.out.println(\"客户端连接了，selectionKey的数量 = \"+selector.keys().size());\n                }\n                //如果key的状态是OP_READ，也就是有数据发送过来了，此时需要读取客户端发送的数据了\n                if (key.isReadable()){\n                    //通过key反向获取到对应的Channel\n                    SocketChannel channel = (SocketChannel)key.channel();\n\n                    //获取到该channel关联的buffer\n                    ByteBuffer buffer = ByteBuffer.allocate(1024);\n                    int read = channel.read(buffer);\n                    if (read > 0){\n                        byte[] data = buffer.array();\n                        String msg = new String(data).trim();\n                        System.out.println(msg);\n                        System.out.println(StandardCharsets.UTF_8.decode(buffer).toString());\n                    }\n                    //System.out.println(\"来自客户端发送的数据是：\"+new String(buffer.array()));\n                    //System.out.println(\"UTF8转码之后\"+ StandardCharsets.UTF_8.decode(buffer).toString());\n                }\n                //手动从集合中移动当前的selectionKey，防止重复操作\n                keyIterator.remove();\n            }\n        }\n    }\n}\n\n```\n\n<br/>\n\n<center>Client端</center>\n\n```java\npackage com.waibizi.socket;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\n\n/**\n * @Author 歪鼻子\n * @Date 2020/6/18 20:56\n * @Description:\n * @Version 1.0\n */\npublic class NIOClient1 {\n    public static void main(String[] args) throws IOException {\n        //得到一个网络通道\n        SocketChannel channel = SocketChannel.open();\n        //设置为非阻塞\n        channel.configureBlocking(false);\n        //提供服务器端的ip和端口\n        InetSocketAddress inetSocketAddress = new InetSocketAddress(\"127.0.0.1\",6666);\n        //连接服务器\n        if (!channel.connect(inetSocketAddress)){\n            while (!channel.finishConnect()){\n                System.out.println(\"客户端可以边连接边进行其他的操作\");\n            }\n        }\n        //如果连接成功，就开始发送数据\n        String msg = \"歪鼻子已就位!\";\n        //将发送数据以字节的形式写入到buffer当中\n        ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());\n        //将buffer写入到channel当中\n        channel.write(buffer);\n        System.in.read();\n    }\n}\npackage com.waibizi.group;\n\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Scanner;\n\n/**\n * @Author 歪鼻子\n * @Date 2020/7/9 16:34\n * @Description:\n * @Version 1.0\n */\npublic class ClientA {\n    /* 服务的IP地址 */\n    private final String HOST = \"127.0.0.1\";\n    /* 服务的端口 */\n    private final int PORT = 2048;\n    private Selector selector;\n    private SocketChannel socketChannel;\n    private String name;\n\n    public ClientA() throws IOException {\n        /* 打开选择器 */\n        selector = Selector.open();\n        /* 连接服务器 */\n        socketChannel = SocketChannel.open(new InetSocketAddress(HOST,PORT));\n        /* 设置为非阻塞状态 */\n        socketChannel.configureBlocking(false);\n        /* 将通道注册到选择器上 */\n        socketChannel.register(selector, SelectionKey.OP_READ);\n        name = \"ClientA\";\n        System.out.println(name+\" is ok····\");\n    }\n    public void send(String info){\n        info = name + \"说：\"+info;\n        try {\n            socketChannel.write(ByteBuffer.wrap(info.getBytes()));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public void read() throws IOException {\n        while (selector.select()>0){\n            Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();\n            while (iterator.hasNext()){\n                SelectionKey key = iterator.next();\n                if (key.isReadable()){\n                    /* 得到相关的通道 */\n                    SocketChannel channel = (SocketChannel) key.channel();\n                    /* 得到一个buffer */\n                    ByteBuffer buffer = ByteBuffer.allocate(1024);\n                    /* 读取 */\n                    channel.read(buffer);\n                    System.out.println(new String(buffer.array()).trim());\n                }\n            }\n            iterator.remove();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        /* 启动客户端 */\n        ClientA client = new ClientA();\n        new Thread(()->{\n            while (true){\n                try {\n                    client.read();\n                    Thread.currentThread().sleep(3000L);\n                } catch (IOException | InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n        /* 向客户端发送数据 */\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextLine()){\n            String msg = scanner.nextLine();\n            client.send(msg);\n        }\n    }\n}\n```\n\n\n\n<center>Server端打印情况</center>\n{% asset_img 6.jpg This is an image %}\n\n\n<center>简单小案例（群聊系统）</center><br/>\n<center>截图效果先</center><br/>\n<center>服务端</center><br/>\n\n{% asset_img 7.jpg This is an image %}\n\n<center>客户端A</center>\n\n{% asset_img 8.jpg This is an image %}\n\n<center>客户端B</center>\n\n{% asset_img 9.jpg This is an image %}\n\n<center>服务端代码（注释同样很丰富，为了方便有截图行号）</center>\n\n```java\npackage com.waibizi.group;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.util.Iterator;\n\n/**\n * @Author 歪鼻子\n * @Date 2020/7/9 14:56\n * @Description: 群聊天，服务端\n * @Version 1.0\n */\npublic class Server {\n    /* 定义属性 */\n    private Selector selector = null;\n    private ServerSocketChannel listenChannel = null;\n    private static final int PORT = 2048;\n\n    /**\n     * 初始化服务端\n     * @throws IOException\n     */\n    public Server() throws IOException {\n        /* 打开选择器 */\n        selector = Selector.open();\n        /* 打开通道 */\n        listenChannel = ServerSocketChannel.open();\n        /* 绑定端口 */\n        listenChannel.socket().bind(new InetSocketAddress(PORT));\n        /* 设置为非阻塞状态 */\n        listenChannel.configureBlocking(false);\n        /* 将通道注册到选择器当中（注意：注册的状态应该是接受的状态） */\n        listenChannel.register(selector, SelectionKey.OP_ACCEPT);\n    }\n    public void listen() throws IOException {\n        while (true) {\n            /* 如果选择器有事件需要处理，也就是选择器的选择大于0 */\n            if (selector.select()>0){\n                /* 遍历得到所有的selectedKey（每个Channel向Selector注册时,都将会创建一个selectionKey） */\n                Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();\n                while (iterator.hasNext()){\n                    /* 取出selectionKey */\n                    SelectionKey key = iterator.next();\n                    /* 监听到key的状态为accept */\n                    if (key.isAcceptable()) {\n                        SocketChannel sc = listenChannel.accept();\n                        /* 将通道收到的socketChannel设置为非阻塞状态 */\n                        sc.configureBlocking(false);\n                        /* 将该socketChannel注册到selector并设置为状态read */\n                        sc.register(selector,SelectionKey.OP_READ);\n                        System.out.println(\"地址是\"+sc.getRemoteAddress().toString().substring(1)+\"的用户上线了\");\n                    }\n                    /* 如果通道是read事件，即通道是可读状态 */\n                    if (key.isReadable()){\n                        read(key);\n                    }\n                    /* 移除已经处理过的selectionKey */\n                    iterator.remove();\n                }\n            }\n        }\n    }\n    /**\n     * 根据key读取消息\n     * @param key\n     */\n    private void read(SelectionKey key){\n        SocketChannel channel = null;\n        /* 得到Key当中的channel */\n        channel = (SocketChannel) key.channel();\n        /* 创建缓冲区 */\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        /* 如果读取到数据 */\n        try {\n            if (channel.read(buffer)>0){\n                /* 把缓冲区的数据转成字符串 */\n                String msg = new String(buffer.array());\n                System.out.println(\"来自客户端的消息：\"+msg.trim());\n                /* 向除了自己的其他客户端转发消息 */\n                sendInformationToOther(msg,channel);\n            }\n        }catch (IOException e){\n            try {\n                System.out.println(channel.getRemoteAddress() + \" 离线了..\");\n                /* 取消注册 */\n                key.cancel();\n                /* 关闭通道 */\n                channel.close();\n            }catch (IOException ee){\n                ee.printStackTrace();\n            }\n        }\n    }\n    private void sendInformationToOther(String msg,SocketChannel self) throws IOException {\n        System.out.println(\"服务器转发消息中······\");\n        /* 遍历所有注册到选择器的Socket并且排除自己 */\n        for (SelectionKey key:selector.keys()){\n            /* 通过key取出channel */\n            Channel target = key.channel();\n            if (target instanceof SocketChannel && target != self){\n                SocketChannel dest = (SocketChannel)target;\n                /* 将msg存储到buffer */\n                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());\n                /* 将buffer的数据写入到通道当中 */\n                dest.write(buffer);\n            }\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        Server server = new Server();\n        server.listen();\n    }\n}\n```\n\n\n\n<center>Client（由于客户端A与B的代码几乎是一致的，所以就只放一个）</center>\n\n```java\npackage com.waibizi.group;\n\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Scanner;\n\n/**\n * @Author 歪鼻子\n * @Date 2020/7/9 16:34\n * @Description:\n * @Version 1.0\n */\npublic class ClientA {\n    /* 服务的IP地址 */\n    private final String HOST = \"127.0.0.1\";\n    /* 服务的端口 */\n    private final int PORT = 2048;\n    private Selector selector;\n    private SocketChannel socketChannel;\n    private String name;\n\n    public ClientA() throws IOException {\n        /* 打开选择器 */\n        selector = Selector.open();\n        /* 连接服务器 */\n        socketChannel = SocketChannel.open(new InetSocketAddress(HOST,PORT));\n        /* 设置为非阻塞状态 */\n        socketChannel.configureBlocking(false);\n        /* 将通道注册到选择器上 */\n        socketChannel.register(selector, SelectionKey.OP_READ);\n        name = \"ClientA\";\n        System.out.println(name+\" is ok····\");\n    }\n    public void send(String info){\n        info = name + \"说：\"+info;\n        try {\n            socketChannel.write(ByteBuffer.wrap(info.getBytes()));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public void read() throws IOException {\n        while (selector.select()>0){\n            Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();\n            while (iterator.hasNext()){\n                SelectionKey key = iterator.next();\n                if (key.isReadable()){\n                    /* 得到相关的通道 */\n                    SocketChannel channel = (SocketChannel) key.channel();\n                    /* 得到一个buffer */\n                    ByteBuffer buffer = ByteBuffer.allocate(1024);\n                    /* 读取 */\n                    channel.read(buffer);\n                    System.out.println(new String(buffer.array()).trim());\n                }\n            }\n            iterator.remove();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        /* 启动客户端 */\n        ClientA client = new ClientA();\n        new Thread(()->{\n            while (true){\n                try {\n                    client.read();\n                    Thread.currentThread().sleep(3000L);\n                } catch (IOException | InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n        /* 向客户端发送数据 */\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextLine()){\n            String msg = scanner.nextLine();\n            client.send(msg);\n        }\n    }\n}\n```\n\n## 四、从传统拷贝到零拷贝\n\n\n<center>我们先来看看传统的文件IO</center><br/>\n\n\n{% asset_img 10.jpg This is an image %}\n\n\n（1）read() syscall ：java客户端（jvm虚拟机）向操作系统\n\n     发起读磁盘数据的请求;\n\n（2）ask for data ：系统向磁盘读数据;\n\n（3）data to kernel buffer through DMA： 磁盘数据通过\n\n      DMA读到内核缓存区\n\n（4）data to kernel buffer through DMA： 磁盘数据通过\n\n      DMA读到内核缓存区\n\n（5）code logic coutinues：业务逻辑处理\n\n（6）wirte() syscall,copies data to kernel socket \n\n    buffer：客户端向系统发起写请求，并且把用户缓冲区数\n    \n    据复制到内核缓冲区<br/>\n\n\n从<font color=\" #FF8C00\">用户态与内核态</font>角度分析\n\nread() syscall：从用户态切换为内核态\n\ncopy data to user buffer：从内核态切换为用户态\n\nwirte() syscall,copies data to kernel socket buffer：从用户态切换为内核态\n\nwrite() returns：从内核态切换为用户态\n\n\n从整体得到角度看，一次IO操作进行了四次用户空间与内核空间的上下文切换，以及四次的数据拷贝（用户拷贝到内核，内核拷贝到用户）;我们在传统的IO当中可以看到，从内核拷贝到用户是没必要的，就是在消耗性能，于是提出了零拷贝机制\n\n\n\n<center>（传统的InputStream与OutputStream就是传统IO）</center>\n<center>Linux2.4之前零拷贝机制</center>\n\n{% asset_img 11.jpg This is an image %}\n\n2.4之前的零拷贝用户与内核上下文切换有两次\n\n\n（1）sendfile() syscall：从用户态切换为内核态\n\n（2）sendfile() returns：从内核态切换为用户态\n\n\n2.4之前的零拷贝数据拷贝有三次\n\ndata to kernel buffer through DMA：磁盘数据通过DMA读到内核缓存区\n\nwirte data to target socket buffer：从内核空间缓冲区写到socket缓冲区\n\n从内核空间缓冲区写到socket缓冲区：socket向目标发送数据\n\n\n（Linux2.4之前的零拷贝是把 kernel buffer 中全部的数据 拷贝到socket buffer）\n\n\n在Linux2.4之后对于零拷贝进行了优化，对于之前的kernel buffer拷贝全部数据优化成了拷贝地址和数据长度（这部分的数据量小到可以忽略不计），当需要真正使用数据的时候，客户端会从socket buffer当中拿到地址与长度，然后到达kernel buffer当中去索取数据进行操作;\n\n","tags":["-IO模型"],"categories":["-BIO、NIO"]},{"title":"synchronized锁升级分析","url":"/2020/06/24/synchronized锁升级分析/","content":"\n## 1.Mutex介绍\n\n  <font color=\" #FF8C00\">Mutex</font>中文名称是<font color=\"#00FA9A\">互斥锁</font>，跟着中文名称很好理解了，就是为了互斥;<br/>\n\n  在并发的情况下，对于一个对象的操作，可能会导致数据不一致性问题，为了保证共享数据操作的完整性。每个对象都对应于一个可称为\" 互斥锁\" 的标记，这个标记用来保证在任一时刻，只能有<font color=\"#00FA9A\">一个线程</font>访问该对象；<br/>\n\n## 2.经典问题引入\n\n  前言：<font color=\"#FF33FF\">synchronized</font>是获取锁对象！！！是一个操作，将锁对象加到代码上面;（这句话多记几遍，不然下面会踩坑） <br/>\n\n  下面这段代码，创建了1000条线程去执行一个static的变量，每一条线程使的count加一，为了使问题更加明显，这里让线程在count++之前，睡眠了一毫秒。在打印输出结果之前，再让主线程睡眠三秒，保证所有线程都执行完再打印数据;原本预期结果是1000，按照正常逻辑也应该是1000.其实不然，每个电脑的结果不同，你自己试着跑一遍吧。<br/>\n\n<center>{% asset_img 1.jpg This is an image %}</center><br/>\n\n  打印出来肯定不是1000，根据<font color=\" #FF8C00\">JMM的模型</font>，可以推断是工作内存的变量没有同步到主内存当中。<br/>\n\n\n<center>{% asset_img 2.jpg This is an image %}</center><br/>\n\n<center>采用synchronized给当前对象加锁，打印结果是1000</center><br/>\n\n<center>{% asset_img 3.jpg This is an image %}</center><br/>\n\n通过字节码分析，可以看到同步的部分是使用<font color=\"#00FA9A\">monitorenter和monitorexit指令</font>。这两个指令隐式地执行了mutex的lock和unlock操作，用于提供原子性的操作;\n\n  这两个指令的命名也有有原因的，原则上他们是获取了这个对象的<font color=\" #FF8C00\">监视器（monitor）</font>,这个过程是排他的，也就是说同一时刻只有一个对象能获取到由synthronized保护的对象;<br/>\n\n\n<center>{% asset_img 4.jpg This is an image %}</center><br/>\n\n<center>好了，我们加上<font color=\" #FF8C00\">synchronized</font>修饰，运行结果是1000毫无疑问的</center><br/>\n\n\n\n## 3.深入了解synchronized\n\n\n\n  首先明确一下我们只需要关注<font color=\"#00FA9A\">对象头</font>的此处位置三个数字，这个地方是对象的锁状态（下面这张图只是举例说明看哪）；<br/>\n\n<center>{% asset_img 5.jpg This is an image %}</center><br/>\n\n<center>然后我们只需关于这些状态</center><br/>\n\n<center>{% asset_img 6.jpg This is an image %}</center><br/>\n\n<center>先来看下锁升级的流程图</center>  <br/>\n\n  在Java SE1.6的时候对于synchronized进行了优化，也就是synchronized在加锁的时候，里面关于锁的机制进行升级，升级的过程如下流程图：<br/>\n\n<center>（以下都是加了synchronized的时候进行分析的结果）</center><br/>\n\n<center>当线程第一次访问这个对象时</center><br/>\n\n<center>{% asset_img 7.jpg This is an image %}</center><br/>\n\n解释：线程一访问到synchronized代码块的时候，先检查对象的标记位，第一次进来的线程肯定不会读到标记检查，就将对象占有，进行标记，然后执行代码块，执行完成之后不会清除对象的标记。（这个过程是偏向锁的过程）<br/>\n\n<center>当有第二个线程接着访问此对象的时候</center><br/>\n\n<center>{% asset_img 8.jpg This is an image %}</center><br/>\n\n解释：当第二个线程访问到synchronized代码块的时候，检查到有标记（因为上一个对象不会清除），判断上一个对象是否存活，如果不存活了，则跟第一个线程进来一样的步骤，如果存活，则进入到<font color=\" #FF8C00\">轻量级锁</font>，也就是<font color=\"#00FA9A\">锁自旋</font>；如果自旋太久了了，也就是大于十次了，就转移到<font color=\"#00FA9A\">重量级锁</font>，将线程挂起；<br/>\n\n## 4.synchronized锁验证\n\n\n\n\n<center>无锁状态</center><br/>\n\n<center>{% asset_img 9.jpg This is an image %}</center><br/>\n\n<center>{% asset_img 10.jpg This is an image %}</center><br/>\n\n<center>偏向锁</center><br/>\n\n\n\n<center>{% asset_img 11.jpg This is an image %}</center><br/>\n\n<center>{% asset_img 12.jpg This is an image %}</center><br/>\n\n<center>解释：因为JVM底层进行加载的时候，会将延时加载的对象加上偏向锁;</center><br/>\n\n<center>注意：此时的偏向锁是一种特殊的偏向锁，具体往下看</center><br/>\n\n<center>{% asset_img 13.jpg This is an image %}</center><br/>\n\n在对象头的位置上，我们可以看到线程ID此时其实是全为零的，再结合偏向锁的概念，偏向锁，偏向、偏向...其实就是偏向了某个线程，此时不偏向其他线程，也可以理解这个就是一个特殊的“无锁”；<br/>\n\n <center>那么怎么让他<font color=\"#00FA9A\">偏向</font>呢？</center> \n\n<center>{% asset_img 14.jpg This is an image %}</center>\n\n<center>上图的代码可以让这把锁进行偏向</center><br/>\n\n<center>{% asset_img 15.jpg This is an image %}</center><br/>\n\n<center>可以看到依然是偏向锁的情况下，有了偏向的线程ID了</center><br/>\n\n<center>注意：你要讲访问的对象加synchronized修饰才有这种效果</center><br/>\n\n\n\n<center>自旋锁(轻量级锁)</center><br/>\n\n  自旋锁是自我上锁了，这个自我上锁的条件，是上一个线程还存活，那么就想办法让线程存活的情况下，再执行一条线程；<br/>\n\n<center>{% asset_img 16.jpg This is an image %}</center><br/>\n\n<center>{% asset_img 17.jpg This is an image %}</center><br/>\n\n在主线程不在睡眠直接加载类的情况下，JVM不底层没有触碰到stu的synchronized代码片段，但是在创建第二个线程创建的时候，JVM底层触碰到了stu的synchronized代码片段，导致了中间会变化了偏向锁，然后根据流程图，第二个线程访问这个具有偏向锁，且第一个线程为消亡的情况下（在main线程当中创建了另外一个线程，main线程肯定还不会消亡），会将偏向锁改为轻量级锁（自旋锁）。<br/>\n\nps:JVM中间转换过程目前能力原因找不到方法去证明，这是一个推断的想法。如果你有方法证明，可以联系一下我吗？<br/>\n\n\n<center>重量级锁</center><br/>\n\n<center>{% asset_img 18.jpg This is an image %}</center><br/>\n\n<center>{% asset_img 19.jpg This is an image %}</center><br/>\n\n  自旋状态还没结束，就会导致不断去自旋，自旋次数超过十了，就会将锁机制转换到重量级锁，这个过程可能比较麻烦去验证，这里主要是证明锁的存在，以及验证什么情况会产生不同的锁。<br/>\n\n<center>【小结】</center><br/>\n\n  synchronized在这此笔记当中只是简单了验证了锁升级，以及synthronized的简单了解。关于synthronized还有<font color=\"#FF33FF\">很多很多</font>需要学习的，锁的加锁过程怎么去debug，发现升级过程这些的，还需要好好加强<br/>\n\n<center>【题外话】</center><br/>\n\n因为有点好奇延迟加载究竟延迟加载多久才加锁，在我自己电脑进行了测试，在写文章的时候是睡眠了这个值，也就是在我自己电脑上，睡眠了这么长的时间情况下，多运行几次会产生在无锁与偏向锁的切换，有兴趣的小伙伴可以自行尝试，然后在下方留言（这个对我有帮助哦，谢谢你啦）<br/>\n\n<center>{% asset_img 20.jpg This is an image %}</center>\n\n","categories":["-Java锁"]},{"title":"【并发基础】Java当中的几个锁概念","url":"/2020/06/15/【并发基础】Java当中的几个锁概念/","content":"\n## 1.前言\n\n  Java对于并发场景，对于锁的使用是最重要的，这次主要是介绍一下Java当中的锁类别与场景：公平锁、非公平锁、乐观锁、悲观锁、偏向锁、轻量级锁、重量级锁、自旋锁、读写锁、锁粗化/锁消除、分段锁;\n\n## 2.公平锁与非公平锁\n\n  正如锁的名字所言，他们的要点就是在于公平或者非公平的这两个意思身上;\n\n  假设我们有如下场景，Thread-1获得锁之后，其他线程如果需要获得锁，不管是公平还是非公平都是需要在外等待的;\n\n<center><font color=\" #FF8C00\">（注意，这里Thread-2到Thread-4是依次到达来等待锁的）</font></center>\n\n  那么接下来的场景就是体现公平锁跟非公平锁的时候了，Thread-1已经释放锁了，而剩下的几个线程都需要这个锁，那么应该怎么去分配锁呢？\n\n  如果是公平锁，那么就是多来了一个线程，也得去队列当中待着，按照线程来竞争锁的顺序一个一个排队;\n\n  如果是非公平锁的话，在Thread-2到Thread-4之间，他们去竞争这把锁的机会是同等的，也就是他们不用排队等待，谁竞争到了就先持有锁;\n\n<center>{% asset_img 1.jpg This is an image %}</center>\n\n实现例子：\n\n注意：你需要了解<b><font color=\" #FF8C00\">ReentrantLock</font></b>的一些常识，例如这是一个可重入的锁，而且默认是非公平锁;\n\n<center>{% asset_img 2.png This is an image %}</center>\n\n<center>{% asset_img 3.png This is an image %}</center>\n\n<center>然后我们运行一下吧</center>\n\n<center>{% asset_img 4.png This is an image %}</center>\n\n<center>{% asset_img 5.png This is an image %}</center>\n\n<center>我们开始start的时候，肯定是外部线程先进去等待了</center>\n\n<center>然后再内部锁进去了等待，那么如果是公平锁</center>\n\n<center>就是大家一起按顺序慢慢等</center>\n\n<center>那么非公平肯定就没有顺序的啦</center>\n\n<center>{% asset_img 6.png This is an image %}</center>\n\n<center>这个位置改一下</center>\n\n<center>然后再次运行就可以看到内部与外部的输出是交替的</center>\n\n<center>{% asset_img 7.png This is an image %}</center>\n\n<center>我这里就随便截图一个输出就行了</center>\n\n<center>可以看到是交替的进行的</center>\n\n<center>也就是不用按照线程去竞争锁的排队顺序的</center>\n\n\n\n<center>大多数锁机制都是默认为非公平锁的</center>\n\n<center>因为非公平锁有着比公平锁更好的性能</center>\n\n<center>由于线程的上下文切换浪费性能</center>\n\n<center>以及需要等待排队线程的唤醒操作等等都会影响浪费性能</center>\n\n## 3.读写锁\n\n\n\n  大多数的人刚开始接触的锁其实都是属于排他锁，也就是线程独占锁，一旦线程占有这把锁的话，其他线程的任何操作想获取锁都是没办法获取的;\n\n  然而在一些特定的场景下，我们并不希望一旦一个线程占有了这个锁，就无法进行其他的操作;\n\n  <b><font color=\" #00FA9A\">读写锁</font></b>：也就是读写锁分离。读锁可以在没有写锁的时候，被多个线程共同占用，而写锁是独占的，也就是只能由一个线程去占用这把锁;\n\n<center>互斥的原则是</center>\n\n<center>多个线程都是读的时候，都是可以共同持有锁</center>\n\n<center>有一个写操作的时候，其他线程<font color=\" #00FA9A\">不能读也不能写</font></center>\n\n\n<center>这里我们模拟一个队列，队列里面有写入操作与读取操作</center>\n\n<center>在写入操作与读取操作的时候，我们分别加上写锁与读锁</center>\n\n<center>{% asset_img 8.png This is an image %}</center>\n\n<center>编写main方法测试</center>\n\n<center>{% asset_img 9.png This is an image %}</center>\n\n\n\n<center>我们从前面的理论知识推断，在读取的时候，</center>\n\n\n<center>写操作是不能<font color=\" #FF8C00\">直接插入</font>的，因为是<b><font color=\" #FF8C00\">互斥的</font></b></center>\n\n<center>也就是写操作的时候，必须在某一个时机</center>\n\n<center>恰好！！读操作释放了锁，写操作接着占用了这把锁</center>\n\n<center><font color=\" #FF8C00\">看下运行结果吧</font></center>\n\n<center>{% asset_img 10.png This is an image %}</center>\n\n\n\n<center>上面的demo只是为了验证锁</center>\n\n<center>我们学习东西主要是为了使用</center>\n\n<center>这个锁在缓存场景其实很适用的</center>\n\n\n回顾一下我们的缓存场景：不就是写的操作比较少，读的情况比较多，我们为了提高速度将缓存放置到内存当中嘛？\n\n\n为了方便模拟的策略，我们先说一下我们要实现的一个小例子：我们模拟在缓存场景下，如果值存在，我们就直接get返回，并且这个get操作是多个线程可以共享的;如果值不存在的情况，多个线程只能有一个线程去获取到锁，并且触发查询数据库的操作;\n\n\n\n<center>{% asset_img 11.png This is an image %}</center>\n\n\n\n## 4.自旋锁\n\n\n\n  有的时候我们加上一些lock操作的时候，会导致上下文切换浪费性能，因为需要上锁再释放锁，有一些持有锁的时间比较短的情况下，我们可以采用<b><font color=\" #00FA9A\">自旋锁</font></b>;\n\n  <b><font color=\" #00FA9A\">自旋锁</font></b>，顾名思义，自我“旋转”就变成了锁，这个自我旋转指的是去旋转CPU的时间片，不上锁的情况让线程在那里进行空转;\n\n\n我们简单看一下需求，如果说主线程的那句打印，我们需要在所有的线程执行完毕之后再开始执行的话，不加lock的情况，我们应该怎么去操作;\n\n{% asset_img 12.png This is an image %}\n\n\n<center>上面代码的执行时打印这样，还没有加自旋锁的情况的</center>\n\n\n<center>{% asset_img 13.png This is an image %}</center>\n\n\n这里由于我的编码工具的缘故，所以我自旋的时候判断线程数目采用了2，不过这不是关键啦，主要是看下自旋的思想\n\n<center>{% asset_img 14.png This is an image %}</center>\n\n\n## 5.偏向锁\n\n\n  <b><font color=\" #FF8C00\">偏向锁</font></b>，在synchronized锁升级时候，有去看到锁升级的采用了偏向锁，至于偏向锁怎么去实现，笔者暂时不清楚怎么去实现;\n\n  <b><font color=\" #00FA9A\">偏向锁</font></b>主要用于大多数情况是一个线程去竞争这把锁的情况，也就是这个锁在大多数情况下，只有一个线程去多次获得。一旦有多个线程来<b><font color=\" #00FA9A\">竞争锁</font></b>了，偏向锁都会升级为其他锁的;\n\n\n## 6.其他几个锁的概念\n\n\n  <b><font color=\" #FF8C00\">悲观锁</font></b>：例如synchronized加锁的情况，就是属于悲观锁，悲观锁，顾名思义，就是比较悲观，每一次我们都必须加锁;\n\n  <b><font color=\" #FF8C00\">乐观锁</font></b>：就是比较少竞争的情况，我们没有进行加锁操作，如果竞争比较严重的时候，我们就对其进行加锁，这个取决于你怎么去实现;\n\n  <b><font color=\" #FF8C00\">重量级锁</font></b>：synchronized就是一把重量级锁，但是synchronized没有那么低效率了，锁升级的过程让synchronized这把有着重量级锁的性能得到了提升;\n\n  <b><font color=\" #FF8C00\">轻量级锁</font></b>：当偏向锁升级成轻量级锁的时候，我们称这种机制是轻量级锁;\n\n  <b><font color=\" #FF8C00\">分段锁</font></b>：并发包下，例如常见的ConcurrentHashMap里面就采用了分段锁，主要是根据锁的位置不是大面积的情况，进行分段加锁;\n\n  <b><font color=\" #FF8C00\">锁粗化</font></b>：如果说加锁位置是一大块的位置，没有更细粒度去加锁位置的话，就是锁粗化;\n\n\n\n  ","tags":["-锁机制"],"categories":["-Java并发"]},{"title":"【线程通信】生产者消费者模型","url":"/2020/06/12/【线程通信】生产者消费者模型/","content":"## 1.生产者消费者模型介绍\n\n\n\n  <font color=\" #FF8C00\">生产者消费者模型，</font>是每一个学习多线程的的人都需要知道的模型;\n\n大致情况就是：有两个线程，一个负责生产产品，一个消费产品，两者公用同一块内存区域，也就是产品放在了同一块内存上面，如果两个线程没有采用一定的措施或者采用的策略错误的情况下，容易出现一系列的问题，例如数据一致性问题，死锁问题;\n\n{% asset_img 1.png This is an image %}\n\n## 2.为什么需要生产者消费者模型\n\n\n\n  在多线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程;如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据;同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者;为了解决这个问题于是引入了生产者和消费者模式。\n\n  \n\n## 3.生产者-消费者模型（线程阻塞，线程唤醒）\n\n\n\n  举例：线程1去奶茶，没有奶茶了，它就不执行了;线程二生产奶茶，通知线程1继续执行;\n\n下面这个例子不大好，使用了Java线程已经抛弃的方法\n{% asset_img 2.png This is an image %}\n\n打印结果如下，最开始没奶茶，后来有了奶茶通知了挂起的线程，那个线程就得以继续执行\n\n<center>{% asset_img 3.png This is an image %}</center>\n\n上面这个就是经典的生产者-消费者模型，但是为啥这个例子当中的线程方法被弃用了呢？往下看一个例子\n\n<center>suspend和resume加锁导致死锁</center>\n\n{% asset_img 4.png This is an image %}\n\n<center>打印结果</center>\n\n<center>{% asset_img 5.png This is an image %}</center>\n\n这个线程不用等了，一直都是在这里挂起了，竞争不到锁，没办法通知挂起的线程继续执行;\n\n\n如果suspend比resume慢执行，也会导致线程永久挂起\n\n{% asset_img 6.png This is an image %}\n\n<center>打印结果，通知完了，那边才开始挂起</center>\n\n<center>{% asset_img 7.png This is an image %}</center>\n\n\n\n<center>那么Java现在推荐哪一种方式进行使用呢~</center>\n\n<center>wait/notify机制</center>\n\n这个机制要求这两个方法只能由同一对象锁的持有者线程进行调用，也就是卸载同步代码块里面，否则会抛出\n\n<center>IllegalMonitorStateException异常</center>\n\n\n\nwait方法导致当前的线程进入等待状态，加入该对象的等待集合中，并发放弃当前持有的对象锁;\n\nnotify/notifyAll方法唤醒一个或所有正在等待这个对象锁的线程;\n\n注意：虽然会wait自动解锁，但是对顺序有要求，如果在notify被调用之后才开始wait方法的调用，线程会永远处于WAITING状态\n\n\n\n<center>先来一个正常的演示（打印跟前面正常的一致）</center>\n\n\n{% asset_img 8.png This is an image %}\n\n<center>可以看到，如果是suspend/resume的话，这个程序是会导致死锁的，可是这里采用的是wait/notify机制，会自动释放锁</center>\n\n\n\n<center>如果notify比waiting先执行</center>\n\n<center>那么会导致线程一直处于WAITING的状态</center>\n\n{% asset_img 9.png This is an image %}\n\n<center></center>说个题外话，我觉得这个就跟你的女神已经通知你，我们不可能在一起了，然后你还一直在等待\n\n\n\n<center>还有另外一个机制</center>\n\n<center><font color=\" #FF8C00\">park/unpark机制</font></center>\n\n<center>park表示等待一个“许可”</center>\n\n<center>unpark表示授予一个\"许可\"</center>\n\n\n\n\n\n<center>park/unpark机制有一个好处就是如果提前颁发“许可”了</center>\n\n<center>也不会导致线程一直处于挂起或者是死锁的转态</center>\n\n<center>但是它不会主动去释放锁</center>\n\n<center>unpark比park提前执行的例子</center>\n\n<center>{% asset_img 10.png This is an image %}</center>\n\n<center>加锁导致死锁的例子</center>\n\n<center>{% asset_img 11.png This is an image %}</center>\n\n<center><font color=\" #00FA9A\">【总结】</font></center>\n\n<center><font color=\" #FF8C00\">suspend/resume机制</font></center>\n\n<center>resume先执行，suspend慢执行;resume/suspend加锁;都会导致死锁</center>\n\n\n\n<center>wait/notify机制</center>\n\n<center>wait/notify加锁了会自动释放锁，但是notify比wait先执行依然会线程永久挂起</center>\n\n\n<center><font color=\" #FF8C00\">park/unpark机制</font></center>\n\npark/unpark不会自动释放锁，但是先后执行顺序不会导致线程永久挂起\n\n\n<center><font color=\" #FF8C00\">【提醒】</font></center>\n\n<center><font color=\" #FF8C00\">代码当中使用if语句来判断是否进入等待状态</font></center>\n\n<center>是错误的</center>\n\n<center>官方建议是采用<font color=\"#00FA9A\">while</font>情况下，判断是否可以将线程挂起</center>"},{"title":"【Java设计模式】代理模式","url":"/2020/06/11/【Java设计模式】代理模式/","content":"\n## 1.Java代理模式的基本介绍\n\n\n  首先得跟大家说明白，本篇文章的设计模式实现是基于<font color=\"#00FA9A\">Java语言</font>的，思想还是代理的思想，不要纠结于我为什么将静态代理，动态代理，cglib代理分开来说（只能说技术是技术，思想是思想）\n\n<font color=\" #FF8C00\">代理模式：</font>为一个对象提供一个替身，以控制对这个对象的访问;即通过代理对象访问目标对象;这样做的好处是可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能;\n\n被代理的对象可以是<font color=\" #FF8C00\">远程的对象</font>、开销大的对象或者需要被安全控制保护的对象;\n\n\nJava的手段实现代理模式的手段主要有三种：<font color=\"#00FA9A\">静态代理，动态代理（JDK代理、接口代理）和cglib代理（cglib代理主要是可以在内存中创建对象，不用实现接口）</font>\n\n\n\n<center>代理模式的类图如下</center>\n\n{% asset_img 1.png This is an image %}\n\n\n  我们要调用<font color=\"#00FA9A\">TargetObject类</font>，也就是目标类的时候，我们（Client）采用调用代理(ProxyObject)的方式去调用最终目标类，进而达到隐藏真正目标类\n\n\n\n## 2.Java实现静态代理\n\n\n\n静态代理：静态代理在使用的时候，需要定义接口或者是父类，被代理对象（即目标对象TargetObject）与代理对象（ProxyObject）一起实现相同的接口或者是继承相同的父类\n\n{% asset_img 2.png This is an image %}\n\n\n类图的意思：假如我是客户（Client）我要去租房，我找到了租房中介（RentingProxy），租房中介与房东（Renting）之间签订了一定的约束，也就是条约。这是采用IRenting来约束;然后我需要租房的时候，只需要找到租房中间去租房就行了，我知道我要租哪间房，我直接调用租房中介有的方法，而租房中介可以帮我处理一些增强方法，例如会提前帮我去看房子合不合格之类的（称之为增强方法）;\n\n代码如下：\n\n<center>包结构</center>\n\n{% asset_img 3.png This is an image %}\n\n客户端类，创建了目标对象，创建了代理对象，然后将目标对象交付给代理对象，使用代理对象执行方法;\n\n{% asset_img 4.png This is an image %}\n\n<center>目标对象与代理对象应该遵守的合约</center>\n\n{% asset_img 5.png This is an image %}\n\n<center><font color=\"#00FA9A\">目标对象</font></center>\n\n{% asset_img 6.png This is an image %}\n\n代理对象，我们可以做一些增强操作\n\n{% asset_img 7.png This is an image %}\n\nClient启动，执行main方法打印\n\n{% asset_img 8.png This is an image %}\n\n## 3.JDK代理\n\n\n\n这里顺便介绍一下动态代理\n\n1.代理对象，不需要实现接口，但是目标对象需要实现接口，\n\n 否则不能使用动态代理\n\n2.代理对象的生成，是利用了JDK的API，动态地在内存中构建\n\n 对象\n\n3.动态代理也叫：<font color=\" #FF8C00\">JDK代理、接口代理</font>\n\n{% asset_img 9.png This is an image %}\n\n采用的案例还是上面那个租房子的案例\n\n\n<center><font color=\" #FF8C00\">包结构</font></center>\n\n{% asset_img 10.png This is an image %}\n\n<center><font color=\" #FF8C00\">Client类</font></center>\n\n{% asset_img 11.png This is an image %}\n\n{% asset_img 12.png This is an image %}\n\n{% asset_img 13.png This is an image %}\n\n这里的JDK动态代理可能会比较难懂，参数的意义我已经加上了\n\n\n{% asset_img 14.png This is an image %}\n\n## 4.Cglib代理\n\n\n\n1.静态代理和JDK动态代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可使用目标对象子类来实现代理，这就是Cglib代理;\n\n2.Cglib代理也叫子类代理，他是在内存中构建一个子类对象从而实现对象功能扩展;\n\n3.Cglib是一个强大的高性能代码生成包，可以在运行期间扩展Java类与实现Java接口;广泛地被许多AOP框架所使用，例如Spring AOP，实现方法拦截;\n\n4.AOP编程当中应该如何选择代理模式\n\n  1）.目标对象需要实现接口，用JDK代理\n\n  2）.目标对象不需要实现接口，用Cgglib代理\n\n5.Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类\n\n<center><font color=\" #FF8C00\">【注意】</font></center>\n\n需要代理的类也就是目标类不能使用final修饰\n\n如果目标类的方法是static/final修饰的，也不能\n\n{% asset_img 15.png This is an image %}\n\n{% asset_img 16.png This is an image %}\n\n{% asset_img 17.png This is an image %}\n\n{% asset_img 18.png This is an image %}\n\n{% asset_img 19.png This is an image %}","tags":["-Java -设计模式"],"categories":["-设计模式"]},{"title":"再谈自动装箱(AutoBoxing)，自动拆箱(Unboxing)","url":"/2020/06/09/再谈自动装箱-AutoBoxing-，自动拆箱-Unboxing/","content":"\n## 1.基础概念\n\n  自动装箱就是自动将基本数据类型转换为**包装器类型**；自动拆箱就是自动将包装器类型转换为**基本数据类型**。<br/>\n\n  ps：Integer自动转换为**<font color=\" #FF8C00\">int</font>**类型，这个就是自动拆箱的过程，int自动转换为Integer就是装箱的过程。<br/>\n\n<div align=\"center\">{% asset_img 1.png This is an image %}</div><br/>\n\n## 2.原理\n\n<center>概念不难理解，不如尝试反编译一下，看下底层是什么什么吧。</center><br/>\n\n<center>废话少说，直接动手肝</center>\n\n<div align=center>{% asset_img 2.png This is an image %}</div>\n\n\n\n  通过**<font color=\" #FF8C00\">反编译字节码</font>**可以很明显地看到一些效果，将**<font color=\" #FF8C00\">装箱与拆箱</font>**的过程反映了出来。<br/>\n\n## 3.自动装箱与拆箱的一些验证\n\n<div align=\"center\">{% asset_img 3.png This is an image %}</div><br/>\n\n<center>打印结果是**<font color=\" #FF8C00\">true</font>**，此步进行了自动拆箱操作</center><br/>\n\n<center><font color=\"#00FA9A\">拆箱</font>的验证，可以通过<font color=\"#00FA9A\">字节码<br/></font>看到</center><br/>\n\n<div align=\"center\">{% asset_img 4.png This is an image %}</div><br/>\n\n<center>再来一次，这次使用<font color=\"#00FA9A\">equals</font>,可以看到是装箱了</center><br/>\n\n<div align=\"center\">{% asset_img 5.png This is an image %}</div><br/>\n\n具体原因是因为jdk内部使用equals的时候，传入是Object，int类型赋值到Object的时候是装箱的过程<br/>\n\n<div align=\"center\">{% asset_img 6.png This is an image %}</div><br/><br/>\n\n<center>小结</center>\n\n1.自动装箱与自动装箱虽然在使用当中可以省略很多不用考虑的因素，但是这是因为Java自己做了这部分的工作（只是你看不到）;\t<br/>\n\n2.大量使用自动装箱会<font color=\"#FF33FF\">影响一部分的性能</font>（因为要生成Object类型）;<br/>\n\n3.采用‘==’与‘equals’的时候，自动装箱与自动拆箱的原因为啥不同;"},{"title":"【CAS基础】CAS简单入门","url":"/2020/06/09/【CAS基础】CAS简单入门/","content":"\n## 1.CAS概念\n\n  首先，跟大家强调一下，CAS是一种思想！！一种思想！！一种思想！！！（重要的话说三次）\n\n  CAS的的英文全称**<font color=\" #FF8C00\">Compare-and-Swap</font>**，中文名称叫做比较并交换，一种才不采用强制性锁机制下的一种值更新策略；在并发的情况下，挺多情况是直接synchronized跟voliate或者其他锁机制实现并发时保证数据一致性的;\n\n## 2.CAS的一个小Demo\n\n  CAS呢，底层是在unsafe类当中的，但是JDK当中有许多类都会采用CAS去保障数据的并发问题，我们简单看一个并发包当中的类，然后去认识CAS吧;\n\n{% asset_img 1.png This is an image %}\n\n<center>这是一个安全的int，我初始化这个int为5，然后采用了</center>\n\n<center>AtomicInteger的CAS实现</center>\n\n<center>大概就是expect期望值是5的话，把值改为update的值</center>\n\n\n\n<center>然后我们就简单进去源码看下吧····</center>\n\n{% asset_img 2.png This is an image %}\n\n\n\n参数的意思:\n\n\n<font color=\" #FF8C00\">this</font>：当前对象\n\n<font color=\" #FF8C00\">valueOffset</font>：内存地址\n\n<font color=\" #FF8C00\">expect</font>：期待值\n\n<font color=\" #FF8C00\">update</font>：更新值\n\n再往下看就不是我们此时关注的重点啦，因为再往下就是unsafe类\n\n这个类我会的后续再写一篇介绍\n\n（真的是太多了）\n\n\n\n## 3.CAS的缺点以及ABA问题\n\n\n  <font color= #7B68EE size=5>无锁机制固然好，但是有一些比较明显的缺点也随着带来了，我们先来简单说一下CAS当中自旋出现的问题;</font>\n\n\n假设我现在有两个线程：线程A与线程B，然后有一个变量，表示的是卡上的余额;\n\n\n\n线程A，此时知道的初始值是50元，线程B也是晓得此时初始值是50元：\n\n线程A想把50更新为100，线程B想把50更新为零，那么此时线程A与线程B的“期望值”都是50，线程A的运气比较好，先抢占到时间片，开始更新数据，并且更新数据成功。而线程B因为一些中间处理操作，需要时间等待，此时拿着期望值“50”，进行CAS比较交换的时候，发现期望值无效，于是重新获取了一次最新的“真实值”，然后很不凑巧，线程A此时又想修改值，而且时间片也被线程A抢占了，线程A此时拿着最新的期望值是“100”，又更新成功了，把值重新改回50，而线程B这倒霉蛋又拿着期望值为“100”的，想过来修改值，又没办法修改···\n\n\n\n如果线程B一直运气不好，抢不到时间片，就会导致线程B一直处于自旋的状态···\n\n\n【ABA问题】\n\nABA问题比较好理解\n\n  1.线程A，期望值是50，欲更新值为100\n\n  2.线程B，期望值是50，欲更新值为100\n\n\n  线程A首先拿到时间片，进行值的更新，此时线程B因为某些问题（阻塞了一段时间），没有抢占到时间片。此时A更新了值了，然后突然来了一个线程C，比线程B先抢占到了时间片（线程B挺可怜的），此时线程C的期望值是100，欲修改值是50，CAS执行成功了，此时线程B终于阻塞完了，拿着期望值为50，更新值为100的操作姗姗来迟，此时CAS也成功了。可是线程B并不知道他自己修改了的值是经过了50->100->50->100。除开掉前面的50是初始值，100,50,100三个数就是ABA的代表，可以将100替换为A理解，50替换为B理解。\n\n\n这个ABA会导致什么问题的出现呢？\n\n\n如果说此时我的银行卡收入了50元，卡内原先余额为50元，此时就要更新为100元，由于一些比较特殊的原因（难不成是工程师的锅），此时50欲更新为100有两条线程，就跟上面例子一样;然后此时突然我的女朋友想要花我的银行卡的钱，我的银行卡也需要扣费了，三个线程出现了上面那种执行顺序问题，我的卡此时不就白白赚了50块钱了吗？（可能例子不大恰当，但是ABA当中就是这种问题的发生）","tags":["CAS","Java"],"categories":["-Java基础"]}]