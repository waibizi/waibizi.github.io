[{"title":"【并发基础】Java当中的几个锁概念","url":"/2020/06/15/【并发基础】Java当中的几个锁概念/","content":"\n## 1.前言\n\n  Java对于并发场景，对于锁的使用是最重要的，这次主要是介绍一下Java当中的锁类别与场景：公平锁、非公平锁、乐观锁、悲观锁、偏向锁、轻量级锁、重量级锁、自旋锁、读写锁、锁粗化/锁消除、分段锁;\n\n## 2.公平锁与非公平锁\n\n  正如锁的名字所言，他们的要点就是在于公平或者非公平的这两个意思身上;\n\n  假设我们有如下场景，Thread-1获得锁之后，其他线程如果需要获得锁，不管是公平还是非公平都是需要在外等待的;\n\n<center><font color=\" #FF8C00\">（注意，这里Thread-2到Thread-4是依次到达来等待锁的）</font></center>\n\n  那么接下来的场景就是体现公平锁跟非公平锁的时候了，Thread-1已经释放锁了，而剩下的几个线程都需要这个锁，那么应该怎么去分配锁呢？\n\n  如果是公平锁，那么就是多来了一个线程，也得去队列当中待着，按照线程来竞争锁的顺序一个一个排队;\n\n  如果是非公平锁的话，在Thread-2到Thread-4之间，他们去竞争这把锁的机会是同等的，也就是他们不用排队等待，谁竞争到了就先持有锁;\n\n<center>{% asset_img 1.jpg This is an image %}</center>\n\n实现例子：\n\n注意：你需要了解<b><font color=\" #FF8C00\">ReentrantLock</font></b>的一些常识，例如这是一个可重入的锁，而且默认是非公平锁;\n\n<center>{% asset_img 2.png This is an image %}</center>\n\n<center>{% asset_img 3.png This is an image %}</center>\n\n<center>然后我们运行一下吧</center>\n\n<center>{% asset_img 4.png This is an image %}</center>\n\n<center>{% asset_img 5.png This is an image %}</center>\n\n<center>我们开始start的时候，肯定是外部线程先进去等待了</center>\n\n<center>然后再内部锁进去了等待，那么如果是公平锁</center>\n\n<center>就是大家一起按顺序慢慢等</center>\n\n<center>那么非公平肯定就没有顺序的啦</center>\n\n<center>{% asset_img 6.png This is an image %}</center>\n\n<center>这个位置改一下</center>\n\n<center>然后再次运行就可以看到内部与外部的输出是交替的</center>\n\n<center>{% asset_img 7.png This is an image %}</center>\n\n<center>我这里就随便截图一个输出就行了</center>\n\n<center>可以看到是交替的进行的</center>\n\n<center>也就是不用按照线程去竞争锁的排队顺序的</center>\n\n\n\n<center>大多数锁机制都是默认为非公平锁的</center>\n\n<center>因为非公平锁有着比公平锁更好的性能</center>\n\n<center>由于线程的上下文切换浪费性能</center>\n\n<center>以及需要等待排队线程的唤醒操作等等都会影响浪费性能</center>\n\n## 3.读写锁\n\n\n\n  大多数的人刚开始接触的锁其实都是属于排他锁，也就是线程独占锁，一旦线程占有这把锁的话，其他线程的任何操作想获取锁都是没办法获取的;\n\n  然而在一些特定的场景下，我们并不希望一旦一个线程占有了这个锁，就无法进行其他的操作;\n\n  <b><font color=\" #00FA9A\">读写锁</font></b>：也就是读写锁分离。读锁可以在没有写锁的时候，被多个线程共同占用，而写锁是独占的，也就是只能由一个线程去占用这把锁;\n\n<center>互斥的原则是</center>\n\n<center>多个线程都是读的时候，都是可以共同持有锁</center>\n\n<center>有一个写操作的时候，其他线程<font color=\" #00FA9A\">不能读也不能写</font></center>\n\n\n<center>这里我们模拟一个队列，队列里面有写入操作与读取操作</center>\n\n<center>在写入操作与读取操作的时候，我们分别加上写锁与读锁</center>\n\n<center>{% asset_img 8.png This is an image %}</center>\n\n<center>编写main方法测试</center>\n\n<center>{% asset_img 9.png This is an image %}</center>\n\n\n\n<center>我们从前面的理论知识推断，在读取的时候，</center>\n\n\n<center>写操作是不能<font color=\" #FF8C00\">直接插入</font>的，因为是<b><font color=\" #FF8C00\">互斥的</font></b></center>\n\n<center>也就是写操作的时候，必须在某一个时机</center>\n\n<center>恰好！！读操作释放了锁，写操作接着占用了这把锁</center>\n\n<center><font color=\" #FF8C00\">看下运行结果吧</font></center>\n\n<center>{% asset_img 10.png This is an image %}</center>\n\n\n\n<center>上面的demo只是为了验证锁</center>\n\n<center>我们学习东西主要是为了使用</center>\n\n<center>这个锁在缓存场景其实很适用的</center>\n\n\n回顾一下我们的缓存场景：不就是写的操作比较少，读的情况比较多，我们为了提高速度将缓存放置到内存当中嘛？\n\n\n为了方便模拟的策略，我们先说一下我们要实现的一个小例子：我们模拟在缓存场景下，如果值存在，我们就直接get返回，并且这个get操作是多个线程可以共享的;如果值不存在的情况，多个线程只能有一个线程去获取到锁，并且触发查询数据库的操作;\n\n\n\n<center>{% asset_img 11.png This is an image %}</center>\n\n\n\n## 4.自旋锁\n\n\n\n  有的时候我们加上一些lock操作的时候，会导致上下文切换浪费性能，因为需要上锁再释放锁，有一些持有锁的时间比较短的情况下，我们可以采用<b><font color=\" #00FA9A\">自旋锁</font></b>;\n\n  <b><font color=\" #00FA9A\">自旋锁</font></b>，顾名思义，自我“旋转”就变成了锁，这个自我旋转指的是去旋转CPU的时间片，不上锁的情况让线程在那里进行空转;\n\n\n我们简单看一下需求，如果说主线程的那句打印，我们需要在所有的线程执行完毕之后再开始执行的话，不加lock的情况，我们应该怎么去操作;\n\n{% asset_img 12.png This is an image %}\n\n\n<center>上面代码的执行时打印这样，还没有加自旋锁的情况的</center>\n\n\n<center>{% asset_img 13.png This is an image %}</center>\n\n\n这里由于我的编码工具的缘故，所以我自旋的时候判断线程数目采用了2，不过这不是关键啦，主要是看下自旋的思想\n\n<center>{% asset_img 14.png This is an image %}</center>\n\n\n## 5.偏向锁\n\n\n  <b><font color=\" #FF8C00\">偏向锁</font></b>，在synchronized锁升级时候，有去看到锁升级的采用了偏向锁，至于偏向锁怎么去实现，笔者暂时不清楚怎么去实现;\n\n  <b><font color=\" #00FA9A\">偏向锁</font></b>主要用于大多数情况是一个线程去竞争这把锁的情况，也就是这个锁在大多数情况下，只有一个线程去多次获得。一旦有多个线程来<b><font color=\" #00FA9A\">竞争锁</font></b>了，偏向锁都会升级为其他锁的;\n\n\n## 6.其他几个锁的概念\n\n\n  <b><font color=\" #FF8C00\">悲观锁</font></b>：例如synchronized加锁的情况，就是属于悲观锁，悲观锁，顾名思义，就是比较悲观，每一次我们都必须加锁;\n\n  <b><font color=\" #FF8C00\">乐观锁</font></b>：就是比较少竞争的情况，我们没有进行加锁操作，如果竞争比较严重的时候，我们就对其进行加锁，这个取决于你怎么去实现;\n\n  <b><font color=\" #FF8C00\">重量级锁</font></b>：synchronized就是一把重量级锁，但是synchronized没有那么低效率了，锁升级的过程让synchronized这把有着重量级锁的性能得到了提升;\n\n  <b><font color=\" #FF8C00\">轻量级锁</font></b>：当偏向锁升级成轻量级锁的时候，我们称这种机制是轻量级锁;\n\n  <b><font color=\" #FF8C00\">分段锁</font></b>：并发包下，例如常见的ConcurrentHashMap里面就采用了分段锁，主要是根据锁的位置不是大面积的情况，进行分段加锁;\n\n  <b><font color=\" #FF8C00\">锁粗化</font></b>：如果说加锁位置是一大块的位置，没有更细粒度去加锁位置的话，就是锁粗化;\n\n\n\n  ","tags":["-锁机制"],"categories":["-Java并发"]},{"title":"【线程通信】生产者消费者模型","url":"/2020/06/12/【线程通信】生产者消费者模型/","content":"## 1.生产者消费者模型介绍\n\n\n\n  <font color=\" #FF8C00\">生产者消费者模型，</font>是每一个学习多线程的的人都需要知道的模型;\n\n大致情况就是：有两个线程，一个负责生产产品，一个消费产品，两者公用同一块内存区域，也就是产品放在了同一块内存上面，如果两个线程没有采用一定的措施或者采用的策略错误的情况下，容易出现一系列的问题，例如数据一致性问题，死锁问题;\n\n{% asset_img 1.png This is an image %}\n\n## 2.为什么需要生产者消费者模型\n\n\n\n  在多线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程;如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据;同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者;为了解决这个问题于是引入了生产者和消费者模式。\n\n  \n\n## 3.生产者-消费者模型（线程阻塞，线程唤醒）\n\n\n\n  举例：线程1去奶茶，没有奶茶了，它就不执行了;线程二生产奶茶，通知线程1继续执行;\n\n下面这个例子不大好，使用了Java线程已经抛弃的方法\n{% asset_img 2.png This is an image %}\n\n打印结果如下，最开始没奶茶，后来有了奶茶通知了挂起的线程，那个线程就得以继续执行\n\n<center>{% asset_img 3.png This is an image %}</center>\n\n上面这个就是经典的生产者-消费者模型，但是为啥这个例子当中的线程方法被弃用了呢？往下看一个例子\n\n<center>suspend和resume加锁导致死锁</center>\n\n{% asset_img 4.png This is an image %}\n\n<center>打印结果</center>\n\n<center>{% asset_img 5.png This is an image %}</center>\n\n这个线程不用等了，一直都是在这里挂起了，竞争不到锁，没办法通知挂起的线程继续执行;\n\n\n如果suspend比resume慢执行，也会导致线程永久挂起\n\n{% asset_img 6.png This is an image %}\n\n<center>打印结果，通知完了，那边才开始挂起</center>\n\n<center>{% asset_img 7.png This is an image %}</center>\n\n\n\n<center>那么Java现在推荐哪一种方式进行使用呢~</center>\n\n<center>wait/notify机制</center>\n\n这个机制要求这两个方法只能由同一对象锁的持有者线程进行调用，也就是卸载同步代码块里面，否则会抛出\n\n<center>IllegalMonitorStateException异常</center>\n\n\n\nwait方法导致当前的线程进入等待状态，加入该对象的等待集合中，并发放弃当前持有的对象锁;\n\nnotify/notifyAll方法唤醒一个或所有正在等待这个对象锁的线程;\n\n注意：虽然会wait自动解锁，但是对顺序有要求，如果在notify被调用之后才开始wait方法的调用，线程会永远处于WAITING状态\n\n\n\n<center>先来一个正常的演示（打印跟前面正常的一致）</center>\n\n\n{% asset_img 8.png This is an image %}\n\n<center>可以看到，如果是suspend/resume的话，这个程序是会导致死锁的，可是这里采用的是wait/notify机制，会自动释放锁</center>\n\n\n\n<center>如果notify比waiting先执行</center>\n\n<center>那么会导致线程一直处于WAITING的状态</center>\n\n{% asset_img 9.png This is an image %}\n\n<center></center>说个题外话，我觉得这个就跟你的女神已经通知你，我们不可能在一起了，然后你还一直在等待\n\n\n\n<center>还有另外一个机制</center>\n\n<center><font color=\" #FF8C00\">park/unpark机制</font></center>\n\n<center>park表示等待一个“许可”</center>\n\n<center>unpark表示授予一个\"许可\"</center>\n\n\n\n\n\n<center>park/unpark机制有一个好处就是如果提前颁发“许可”了</center>\n\n<center>也不会导致线程一直处于挂起或者是死锁的转态</center>\n\n<center>但是它不会主动去释放锁</center>\n\n<center>unpark比park提前执行的例子</center>\n\n<center>{% asset_img 10.png This is an image %}</center>\n\n<center>加锁导致死锁的例子</center>\n\n<center>{% asset_img 11.png This is an image %}</center>\n\n<center><font color=\" #00FA9A\">【总结】</font></center>\n\n<center><font color=\" #FF8C00\">suspend/resume机制</font></center>\n\n<center>resume先执行，suspend慢执行;resume/suspend加锁;都会导致死锁</center>\n\n\n\n<center>wait/notify机制</center>\n\n<center>wait/notify加锁了会自动释放锁，但是notify比wait先执行依然会线程永久挂起</center>\n\n\n<center><font color=\" #FF8C00\">park/unpark机制</font></center>\n\npark/unpark不会自动释放锁，但是先后执行顺序不会导致线程永久挂起\n\n\n<center><font color=\" #FF8C00\">【提醒】</font></center>\n\n<center><font color=\" #FF8C00\">代码当中使用if语句来判断是否进入等待状态</font></center>\n\n<center>是错误的</center>\n\n<center>官方建议是采用<font color=\"#00FA9A\">while</font>情况下，判断是否可以将线程挂起</center>"},{"title":"【Java设计模式】代理模式","url":"/2020/06/11/【Java设计模式】代理模式/","content":"\n## 1.Java代理模式的基本介绍\n\n\n  首先得跟大家说明白，本篇文章的设计模式实现是基于<font color=\"#00FA9A\">Java语言</font>的，思想还是代理的思想，不要纠结于我为什么将静态代理，动态代理，cglib代理分开来说（只能说技术是技术，思想是思想）\n\n<font color=\" #FF8C00\">代理模式：</font>为一个对象提供一个替身，以控制对这个对象的访问;即通过代理对象访问目标对象;这样做的好处是可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能;\n\n被代理的对象可以是<font color=\" #FF8C00\">远程的对象</font>、开销大的对象或者需要被安全控制保护的对象;\n\n\nJava的手段实现代理模式的手段主要有三种：<font color=\"#00FA9A\">静态代理，动态代理（JDK代理、接口代理）和cglib代理（cglib代理主要是可以在内存中创建对象，不用实现接口）</font>\n\n\n\n<center>代理模式的类图如下</center>\n\n{% asset_img 1.png This is an image %}\n\n\n  我们要调用<font color=\"#00FA9A\">TargetObject类</font>，也就是目标类的时候，我们（Client）采用调用代理(ProxyObject)的方式去调用最终目标类，进而达到隐藏真正目标类\n\n\n\n## 2.Java实现静态代理\n\n\n\n静态代理：静态代理在使用的时候，需要定义接口或者是父类，被代理对象（即目标对象TargetObject）与代理对象（ProxyObject）一起实现相同的接口或者是继承相同的父类\n\n{% asset_img 2.png This is an image %}\n\n\n类图的意思：假如我是客户（Client）我要去租房，我找到了租房中介（RentingProxy），租房中介与房东（Renting）之间签订了一定的约束，也就是条约。这是采用IRenting来约束;然后我需要租房的时候，只需要找到租房中间去租房就行了，我知道我要租哪间房，我直接调用租房中介有的方法，而租房中介可以帮我处理一些增强方法，例如会提前帮我去看房子合不合格之类的（称之为增强方法）;\n\n代码如下：\n\n<center>包结构</center>\n\n{% asset_img 3.png This is an image %}\n\n客户端类，创建了目标对象，创建了代理对象，然后将目标对象交付给代理对象，使用代理对象执行方法;\n\n{% asset_img 4.png This is an image %}\n\n<center>目标对象与代理对象应该遵守的合约</center>\n\n{% asset_img 5.png This is an image %}\n\n<center><font color=\"#00FA9A\">目标对象</font></center>\n\n{% asset_img 6.png This is an image %}\n\n代理对象，我们可以做一些增强操作\n\n{% asset_img 7.png This is an image %}\n\nClient启动，执行main方法打印\n\n{% asset_img 8.png This is an image %}\n\n## 3.JDK代理\n\n\n\n这里顺便介绍一下动态代理\n\n1.代理对象，不需要实现接口，但是目标对象需要实现接口，\n\n 否则不能使用动态代理\n\n2.代理对象的生成，是利用了JDK的API，动态地在内存中构建\n\n 对象\n\n3.动态代理也叫：<font color=\" #FF8C00\">JDK代理、接口代理</font>\n\n{% asset_img 9.png This is an image %}\n\n采用的案例还是上面那个租房子的案例\n\n\n<center><font color=\" #FF8C00\">包结构</font></center>\n\n{% asset_img 10.png This is an image %}\n\n<center><font color=\" #FF8C00\">Client类</font></center>\n\n{% asset_img 11.png This is an image %}\n\n{% asset_img 12.png This is an image %}\n\n{% asset_img 13.png This is an image %}\n\n这里的JDK动态代理可能会比较难懂，参数的意义我已经加上了\n\n\n{% asset_img 14.png This is an image %}\n\n## 4.Cglib代理\n\n\n\n1.静态代理和JDK动态代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可使用目标对象子类来实现代理，这就是Cglib代理;\n\n2.Cglib代理也叫子类代理，他是在内存中构建一个子类对象从而实现对象功能扩展;\n\n3.Cglib是一个强大的高性能代码生成包，可以在运行期间扩展Java类与实现Java接口;广泛地被许多AOP框架所使用，例如Spring AOP，实现方法拦截;\n\n4.AOP编程当中应该如何选择代理模式\n\n  1）.目标对象需要实现接口，用JDK代理\n\n  2）.目标对象不需要实现接口，用Cgglib代理\n\n5.Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类\n\n<center><font color=\" #FF8C00\">【注意】</font></center>\n\n需要代理的类也就是目标类不能使用final修饰\n\n如果目标类的方法是static/final修饰的，也不能\n\n{% asset_img 15.png This is an image %}\n\n{% asset_img 16.png This is an image %}\n\n{% asset_img 17.png This is an image %}\n\n{% asset_img 18.png This is an image %}\n\n{% asset_img 19.png This is an image %}","tags":["-Java -设计模式"],"categories":["-设计模式"]},{"title":"再谈自动装箱(AutoBoxing)，自动拆箱(Unboxing)","url":"/2020/06/09/再谈自动装箱-AutoBoxing-，自动拆箱-Unboxing/","content":"\n## 1.基础概念\n\n  自动装箱就是自动将基本数据类型转换为**包装器类型**；自动拆箱就是自动将包装器类型转换为**基本数据类型**。\n\n  ps：Integer自动转换为**<font color=\" #FF8C00\">int</font>**类型，这个就是自动拆箱的过程，int自动转换为Integer就是装箱的过程。\n\n{% asset_img 1.png This is an image %}\n\n## 2.原理\n\n  概念不难理解，不如尝试反编译一下，看下底层是什么什么吧。\n\n  废话少说，直接动手肝\n\n点击查看大图\n\n{% asset_img 2.png This is an image %}\n\n  通过**<font color=\" #FF8C00\">反编译字节码</font>**可以很明显地看到一些效果，将**<font color=\" #FF8C00\">装箱与拆箱</font>**的过程反映了出来。\n\n## 3.自动装箱与拆箱的一些验证\n\n{% asset_img 3.png This is an image %}\n\n打印结果是**<font color=\" #FF8C00\">true</font>**，此步进行了自动拆箱操作\n\n<font color=\"#00FA9A\">拆箱</font>的验证，可以通过<font color=\"#00FA9A\">字节码</font>看到\n\n{% asset_img 4.png This is an image %}\n\n<center>再来一次，这次使用<font color=\"#00FA9A\">equals</font>,可以看到是装箱了</center>\n\n{% asset_img 5.png This is an image %}\n\n具体原因是因为jdk内部使用equals的时候，传入是Object，int类型赋值到Object的时候是装箱的过程\n\n{% asset_img 6.png This is an image %}\n\n**小结**\n\n1.自动装箱与自动装箱虽然在使用当中可以省略很多不用考虑的因素，但是这是因为Java自己做了这部分的工作（只是你看不到）;\n\n2.大量使用自动装箱会影响一部分的性能（因为要生成Object类型）;\n\n3.采用‘==’与‘equals’的时候，自动装箱与自动拆箱的原因为啥不同;"},{"title":"【CAS基础】CAS简单入门","url":"/2020/06/09/【CAS基础】CAS简单入门/","content":"\n## 1.CAS概念\n\n  首先，跟大家强调一下，CAS是一种思想！！一种思想！！一种思想！！！（重要的话说三次）\n\n  CAS的的英文全称**<font color=\" #FF8C00\">Compare-and-Swap</font>**，中文名称叫做比较并交换，一种才不采用强制性锁机制下的一种值更新策略；在并发的情况下，挺多情况是直接synchronized跟voliate或者其他锁机制实现并发时保证数据一致性的;\n\n## 2.CAS的一个小Demo\n\n  CAS呢，底层是在unsafe类当中的，但是JDK当中有许多类都会采用CAS去保障数据的并发问题，我们简单看一个并发包当中的类，然后去认识CAS吧;\n\n{% asset_img 1.png This is an image %}\n\n<center>这是一个安全的int，我初始化这个int为5，然后采用了</center>\n\n<center>AtomicInteger的CAS实现</center>\n\n<center>大概就是expect期望值是5的话，把值改为update的值</center>\n\n\n\n<center>然后我们就简单进去源码看下吧····</center>\n\n{% asset_img 2.png This is an image %}\n\n\n\n参数的意思:\n\n\n<font color=\" #FF8C00\">this</font>：当前对象\n\n<font color=\" #FF8C00\">valueOffset</font>：内存地址\n\n<font color=\" #FF8C00\">expect</font>：期待值\n\n<font color=\" #FF8C00\">update</font>：更新值\n\n再往下看就不是我们此时关注的重点啦，因为再往下就是unsafe类\n\n这个类我会的后续再写一篇介绍\n\n（真的是太多了）\n\n\n\n## 3.CAS的缺点以及ABA问题\n\n\n  <font color= #7B68EE size=5>无锁机制固然好，但是有一些比较明显的缺点也随着带来了，我们先来简单说一下CAS当中自旋出现的问题;</font>\n\n\n假设我现在有两个线程：线程A与线程B，然后有一个变量，表示的是卡上的余额;\n\n\n\n线程A，此时知道的初始值是50元，线程B也是晓得此时初始值是50元：\n\n线程A想把50更新为100，线程B想把50更新为零，那么此时线程A与线程B的“期望值”都是50，线程A的运气比较好，先抢占到时间片，开始更新数据，并且更新数据成功。而线程B因为一些中间处理操作，需要时间等待，此时拿着期望值“50”，进行CAS比较交换的时候，发现期望值无效，于是重新获取了一次最新的“真实值”，然后很不凑巧，线程A此时又想修改值，而且时间片也被线程A抢占了，线程A此时拿着最新的期望值是“100”，又更新成功了，把值重新改回50，而线程B这倒霉蛋又拿着期望值为“100”的，想过来修改值，又没办法修改···\n\n\n\n如果线程B一直运气不好，抢不到时间片，就会导致线程B一直处于自旋的状态···\n\n\n【ABA问题】\n\nABA问题比较好理解\n\n  1.线程A，期望值是50，欲更新值为100\n\n  2.线程B，期望值是50，欲更新值为100\n\n\n  线程A首先拿到时间片，进行值的更新，此时线程B因为某些问题（阻塞了一段时间），没有抢占到时间片。此时A更新了值了，然后突然来了一个线程C，比线程B先抢占到了时间片（线程B挺可怜的），此时线程C的期望值是100，欲修改值是50，CAS执行成功了，此时线程B终于阻塞完了，拿着期望值为50，更新值为100的操作姗姗来迟，此时CAS也成功了。可是线程B并不知道他自己修改了的值是经过了50->100->50->100。除开掉前面的50是初始值，100,50,100三个数就是ABA的代表，可以将100替换为A理解，50替换为B理解。\n\n\n这个ABA会导致什么问题的出现呢？\n\n\n如果说此时我的银行卡收入了50元，卡内原先余额为50元，此时就要更新为100元，由于一些比较特殊的原因（难不成是工程师的锅），此时50欲更新为100有两条线程，就跟上面例子一样;然后此时突然我的女朋友想要花我的银行卡的钱，我的银行卡也需要扣费了，三个线程出现了上面那种执行顺序问题，我的卡此时不就白白赚了50块钱了吗？（可能例子不大恰当，但是ABA当中就是这种问题的发生）","tags":["CAS","Java"],"categories":["-Java基础"]}]